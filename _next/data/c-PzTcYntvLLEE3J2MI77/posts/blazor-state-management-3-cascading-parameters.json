{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"This article explores cascading values in Blazor 0.7.0\")), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"The source code for this article can be found \", mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://github.com/dworthen/BlazorStateManagement/tree/part-03-cascading-parameters\"\n  }, \"here\")))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"This article is part of a Blazor state management exploration series.\")), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/posts/blazor-state-management-1-data-binding\"\n  }, \"Blazor State Management Part I - Data-Binding\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/posts/blazor-state-management-2-event-delegation\"\n  }, \"Blazor State Management Part II - Event Delegation\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Blazor State Management Part III - Cascading Parameters\")), mdx(\"hr\", null), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/posts/blazor-state-management-2-event-delegation\"\n  }, \"The last article\"), \" ended with a question. How do we share data within the following component structure?\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/event-delegation-complicated.png\",\n    \"alt\": \"Cascading parameters.\"\n  })), mdx(\"p\", null, \"With event delegation, we could update middle components to accept a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"person\"), \" parameter and pass it through to child components that need it. We would also need to pass event handlers through the middle components. A doable, but a messy and cumbersome process.\"), mdx(\"p\", null, \"Ideally, we would pass parameters from the parent component directly to child components that need them, no matter how nested the child components are. Well, it turns out, we can. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/aspnet/core/razor-components/components?view=aspnetcore-3.0#cascading-values-and-parameters\"\n  }, \"CascadingValue\"), \" is a unique tag that allows us to hoist parameters for child components, even nested ones, to acccess. This should feel familiar to anyone who has used \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/docs/context.html\"\n  }, \"React context\"), \".\"), mdx(\"p\", null, \"Let's create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MiddleComponent\"), \" to contain the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DisplayPerson\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \" components.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* MiddleComponent.cshtml *@\\n<div class=\\\"boxed\\\">\\n    <h4>DisplayPerson Component</h4>\\n    <DisplayPerson></DisplayPerson3>\\n</div>\\n<div class=\\\"boxed\\\">\\n    <h4>UpdatePerson Componet</h4>\\n    <UpdatePerson></UpdatePerson3>\\n</div>\\n\")), mdx(\"p\", null, \"Notice that we are no longer passing parameters to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DisplayPerson\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \". This is because the components will check the hoisted space for the values instead of receiving them directly as parameters. Update \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.cshtml\"), \" to use the newly created \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MiddleComponent\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* index.cshtml *@\\n...\\n<MiddleComponent></MiddleComponent>\\n\\n@functions {\\n    protected Person person { get; set; } = new Person { Name = \\\"Derek\\\" };\\n    ...\\n}\\n\")), mdx(\"p\", null, \"This will not work. Remember, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DisplayPerson\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \" need a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" object to work with. So let's wrap \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MiddleComponent\"), \" in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CascadingValue\"), \" component to hoist our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"person\"), \" object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* index.cshtml *@\\n...\\n<CascadingValue Value=\\\"@person\\\">\\n    <MiddleComponent></MiddleComponent>\\n</CascadingValue>\\n...\\n\")), mdx(\"p\", null, \"This is still not enough. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \" also expects a function parameter. A function that will handle updating the state when necessary. Each \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CascadingValue\"), \" can only hoist one value so we will need to nest tags. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* index.cshtml *@\\n<CascadingValue Value=\\\"@person\\\">\\n    <CascadingValue \\n        Value=\\\"@HandleChange\\\" \\n        Name=\\\"HandleChange\\\" \\n        T=\\\"Action<UIChangeEventArgs>\\\">\\n        <MiddleComponent></MiddleComponent>\\n    </CascadingValue>\\n</CascadingValue>\\n\\n@functions {\\n    protected Person person { get; set; } = new Person { Name = \\\"Derek\\\" };\\n    protected void HandleChange (UIChangeEventArgs e)\\n    {\\n        person.Name = e.Value.ToString();\\n        StateHasChanged();\\n    }\\n}\\n\")), mdx(\"p\", null, \"The second \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CascadingValue\"), \" component is hoisting a named parameter. Since the parameter is a method, we need to help Blazor identify the parameter type by specifying the type with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T\"), \" parameter.\"), mdx(\"p\", null, \"Next, we need to update \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DisplayPerson\"), \" to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CascadingParameters\"), \" instead of normal parameters. We only need to update the decorators to specify \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CascadingParameters\"), \". Nothing else needs to change.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-apsnet\"\n  }, \"@* UpdatePerson.cshtml *@\\n...\\n@functions {\\n    [CascadingParameter] \\n    protected Person person { get; set; }\\n    [CascadingParameter(Name = \\\"HandleChange\\\")] \\n    protected Action<UIChangeEventArgs> CustomOnChange { get; set; }\\n    ...\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* DisplayPerson.cshtml *@\\n...\\n@functions {\\n    [CascadingParameter] protected Person person { get; set; }\\n}\\n\")), mdx(\"p\", null, \"Our application should work as it did at the end of the event delegation article. Updating the person's name using the input field should update the name displayed in all components. \"), mdx(\"hr\", null), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"Yes, it is possible to use cascading parameters to share state throughout an application, but it is messy. The Blazor docs use CSS style rules or theme information as an example for using cascading parameters. read-only UI state or theme information are good candidates for cascading parameters. Otherwise, not only do the values need to be cascaded but so do the methods that will be responsible for updating the hoisted values. Not to mention, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CascadingValue\"), \" can only hoist one value at a time, requiring nested tags for each cascading value.\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<blockquote><p><strong>This article explores cascading values in Blazor 0.7.0</strong></p><p><strong>The source code for this article can be found <a href=\"https://github.com/dworthen/BlazorStateManagement/tree/part-03-cascading-parameters\">here</a></strong></p></blockquote><p><strong>This article is part of a Blazor state management exploration series.</strong></p><ol><li><a href=\"/posts/blazor-state-management-1-data-binding\">Blazor State Management Part I - Data-Binding</a></li><li><a href=\"/posts/blazor-state-management-2-event-delegation\">Blazor State Management Part II - Event Delegation</a></li><li>Blazor State Management Part III - Cascading Parameters</li></ol><hr/><p><a href=\"/posts/blazor-state-management-2-event-delegation\">The last article</a> ended with a question. How do we share data within the following component structure?</p><p><img src=\"/media/event-delegation-complicated.png\" alt=\"Cascading parameters.\"/></p><p>With event delegation, we could update middle components to accept a <code>person</code> parameter and pass it through to child components that need it. We would also need to pass event handlers through the middle components. A doable, but a messy and cumbersome process.</p><p>Ideally, we would pass parameters from the parent component directly to child components that need them, no matter how nested the child components are. Well, it turns out, we can. <a href=\"https://docs.microsoft.com/en-us/aspnet/core/razor-components/components?view=aspnetcore-3.0#cascading-values-and-parameters\">CascadingValue</a> is a unique tag that allows us to hoist parameters for child components, even nested ones, to acccess. This should feel familiar to anyone who has used <a href=\"https://reactjs.org/docs/context.html\">React context</a>.</p><p>Let&#x27;s create a <code>MiddleComponent</code> to contain the <code>DisplayPerson</code> and <code>UpdatePerson</code> components.</p><pre><code class=\"language-aspnet\">@* MiddleComponent.cshtml *@\n&lt;div class=&quot;boxed&quot;&gt;\n    &lt;h4&gt;DisplayPerson Component&lt;/h4&gt;\n    &lt;DisplayPerson&gt;&lt;/DisplayPerson3&gt;\n&lt;/div&gt;\n&lt;div class=&quot;boxed&quot;&gt;\n    &lt;h4&gt;UpdatePerson Componet&lt;/h4&gt;\n    &lt;UpdatePerson&gt;&lt;/UpdatePerson3&gt;\n&lt;/div&gt;\n</code></pre><p>Notice that we are no longer passing parameters to <code>DisplayPerson</code> or <code>UpdatePerson</code>. This is because the components will check the hoisted space for the values instead of receiving them directly as parameters. Update <code>index.cshtml</code> to use the newly created <code>MiddleComponent</code>.</p><pre><code class=\"language-aspnet\">@* index.cshtml *@\n...\n&lt;MiddleComponent&gt;&lt;/MiddleComponent&gt;\n\n@functions {\n    protected Person person { get; set; } = new Person { Name = &quot;Derek&quot; };\n    ...\n}\n</code></pre><p>This will not work. Remember, <code>DisplayPerson</code> and <code>UpdatePerson</code> need a <code>Person</code> object to work with. So let&#x27;s wrap <code>MiddleComponent</code> in a <code>CascadingValue</code> component to hoist our <code>person</code> object.</p><pre><code class=\"language-aspnet\">@* index.cshtml *@\n...\n&lt;CascadingValue Value=&quot;@person&quot;&gt;\n    &lt;MiddleComponent&gt;&lt;/MiddleComponent&gt;\n&lt;/CascadingValue&gt;\n...\n</code></pre><p>This is still not enough. <code>UpdatePerson</code> also expects a function parameter. A function that will handle updating the state when necessary. Each <code>CascadingValue</code> can only hoist one value so we will need to nest tags. </p><pre><code class=\"language-aspnet\">@* index.cshtml *@\n&lt;CascadingValue Value=&quot;@person&quot;&gt;\n    &lt;CascadingValue \n        Value=&quot;@HandleChange&quot; \n        Name=&quot;HandleChange&quot; \n        T=&quot;Action&lt;UIChangeEventArgs&gt;&quot;&gt;\n        &lt;MiddleComponent&gt;&lt;/MiddleComponent&gt;\n    &lt;/CascadingValue&gt;\n&lt;/CascadingValue&gt;\n\n@functions {\n    protected Person person { get; set; } = new Person { Name = &quot;Derek&quot; };\n    protected void HandleChange (UIChangeEventArgs e)\n    {\n        person.Name = e.Value.ToString();\n        StateHasChanged();\n    }\n}\n</code></pre><p>The second <code>CascadingValue</code> component is hoisting a named parameter. Since the parameter is a method, we need to help Blazor identify the parameter type by specifying the type with the <code>T</code> parameter.</p><p>Next, we need to update <code>UpdatePerson</code> and <code>DisplayPerson</code> to use <code>CascadingParameters</code> instead of normal parameters. We only need to update the decorators to specify <code>CascadingParameters</code>. Nothing else needs to change.</p><pre><code class=\"language-apsnet\">@* UpdatePerson.cshtml *@\n...\n@functions {\n    [CascadingParameter] \n    protected Person person { get; set; }\n    [CascadingParameter(Name = &quot;HandleChange&quot;)] \n    protected Action&lt;UIChangeEventArgs&gt; CustomOnChange { get; set; }\n    ...\n}\n</code></pre><pre><code class=\"language-aspnet\">@* DisplayPerson.cshtml *@\n...\n@functions {\n    [CascadingParameter] protected Person person { get; set; }\n}\n</code></pre><p>Our application should work as it did at the end of the event delegation article. Updating the person&#x27;s name using the input field should update the name displayed in all components. </p><hr/><h2>Conclusion</h2><p>Yes, it is possible to use cascading parameters to share state throughout an application, but it is messy. The Blazor docs use CSS style rules or theme information as an example for using cascading parameters. read-only UI state or theme information are good candidates for cascading parameters. Otherwise, not only do the values need to be cascaded but so do the methods that will be responsible for updating the hoisted values. Not to mention, <code>CascadingValue</code> can only hoist one value at a time, requiring nested tags for each cascading value.</p>","scope":{}},"frontMatter":{"template":"post","title":"Blazor State Management Part III - Cascading Parameters","slug":"blazor-state-management-3-cascading-parameters","published":true,"date":"2019-03-16","description":"Cascading parameters provides a way to share data and behavior from ancestor components to child components without having to manually pass parameters down in intermediate components. Components can access the data it needs without requiring parent components to manage data dependencies. In this article, we will explore using cascading parameters, along with event delegation, in order to share data throughout a component tree.","category":"Blazor","tags":["Blazor"]}},"__N_SSG":true}