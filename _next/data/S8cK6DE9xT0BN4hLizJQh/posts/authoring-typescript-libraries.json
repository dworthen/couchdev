{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Problem\"), mdx(\"p\", null, \"You've written a TypeScript library. Now what? Time to publish, of course. But how? Do you publish it as a TypeScript module or compile it to JavaScript? Should it run in browser or Node.js? Or both? What about ES5 versus ES6 or ESNext? And don't forget, some people prefer AMD modules.\"), mdx(\"p\", null, \"In this article, I address all of these concerns and more. I will show you how to publish a TypeScript library to a broad audience. Publishing a TypeScript library can be complicated, but it doesn't have to be.\"), mdx(\"h2\", null, \"TLDR\"), mdx(\"p\", null, \"Use tsc to compile TypeScript source code to ES modules. Use webpack + babel to transpile ES modules to a umd package. Providing ES modules and a umd package supports a larger developer community.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Solution\"), mdx(\"p\", null, \"A two-step build process.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Compile TypeScript source code to ES modules using \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tsc\"), \", the TypeScript compiler.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Bundle ES modules into a single umd module using webpack and babel.\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Why\"), mdx(\"p\", null, \"Providing both ES modules and a umd package gives developers options. Those working in modern ES2015+ environments can use the ES modules while the umd package supports those working in commonjs or web browser environments. Plus, modern build tools, such as Webpack and rollup, take advantage of ES modules. Build tools will parse, traverse and eliminate unused (dead) code of ES module dependencies.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Why Webpack\"), mdx(\"p\", null, \"Unfortunately, the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Microsoft/TypeScript/issues/8436\"\n  }, \"TypeScript compiler does not support global fallbacks when compiling to umd\"), \". In short, umd packages produced by TypeScript do not support web browsers. Webpack, on the other hand, builds umd packages that support web browsers along with commonjs and amd environments.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Why Babel\"), mdx(\"p\", null, \"To transpile ES2015 to the more widely supported ES5.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Is Compilation Necessary\"), mdx(\"p\", null, \"What about writing TypeScript libraries for TypeScript developers? Is a build process necessary?\"), mdx(\"p\", null, \"Yes. TypeScript does not compile dependencies (packages listed in node_modules). TypeScript libraries need to be compiled to JavaScript before publishing, even if the intended audience is TypeScript developers.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Project Structure\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-asciidoc\"\n  }, \"Project/\\n|-- src/\\n    |-- sayHello.ts\\n    |-- index.ts\\n|-- tsconfig.json\\n|-- webpack.config.js\\n|-- package.json\\n\")), mdx(\"h3\", null, \"sayHello.ts\"), mdx(\"p\", null, \"A simple function to say hello! This is the only functionality of my awesome library.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function sayHello(name: string): void {\\n  console.log(`Hello, ${name}`);\\n}\\n\")), mdx(\"h3\", null, \"index.ts\"), mdx(\"p\", null, \"This is the main entry point to the library and, as such, exposes the public API.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export { sayHello } from \\\"./sayHello\\\";\\n\")), mdx(\"h3\", null, \"tsconfig.json\"), mdx(\"p\", null, \"The following options instruct the TypeScript compiler to output ES2015 modules.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n  \\\"compilerOptions\\\": {\\n    /* Basic Options */\\n    \\\"target\\\": \\\"ES2015\\\" /* Build to ES2015 */,\\n    \\\"module\\\": \\\"ES2015\\\" /* using ES2015 modules */,\\n    \\\"lib\\\": [\\\"es2015\\\", \\\"dom\\\"] /* Using ES2015 features and DOM APIs  */,\\n    \\\"declaration\\\": true /* Generates corresponding'.d.ts' files. */,\\n    \\\"declarationDir\\\": \\\"./dist/typings/\\\" /* build '.d.ts' files to ./dist/typeings */,\\n    \\\"outDir\\\": \\\"./dist/esm/\\\" /* build to ./dist/esm/ */\\n  },\\n  \\\"files\\\": [\\\"./src/index.ts\\\"],\\n  \\\"include\\\": [\\\"./src/**/*.ts\\\"]\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"declarations\"), \": set to true, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tsc\"), \" outputs type definition files which, in turn, provides code intellisense support to TypeScript developers using the library.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"files\"), \" specifies which files to compile. In this case, the main entry point to the library is listed. Compiling the main entry point, index.ts, compiles the rest of the library through dependencies.\")), mdx(\"h3\", null, \"webpack.config.js\"), mdx(\"p\", null, \"Webpack bundles ES modules outputted by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tsc\"), \" as a single umd package, targeting ES5. Developers can load the umd package within web browsers, via a script tag, or within commonjs or amd environments.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const path = require(\\\"path\\\");\\n\\nmodule.exports = (env, argv) => {\\n  return {\\n    entry: {\\n      index: path.resolve(__dirname, \\\"./dist/esm/index.js\\\")\\n    },\\n    output: {\\n      path: path.resolve(__dirname, \\\"./dist/umd\\\"), // builds to ./dist/umd/\\n      filename: \\\"[name].js\\\", // index.js\\n      library: \\\"myLibrary\\\", // aka window.myLibrary\\n      libraryTarget: \\\"umd\\\", // supports commonjs, amd and web browsers\\n      globalObject: \\\"this\\\"\\n    },\\n    module: {\\n      rules: [{ test: /\\\\.t|js$/, use: \\\"babel-loader\\\" }]\\n    }\\n  };\\n};\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"entry\"), \" specifies the entry point to the library. In this setup, webpack transpiles ES2015 to ES5 and does not compile TypeScript source code. For this reason, the file outputted by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tsc\"), \", which is an ES2015 module, is specified as the input for webpack.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"library\"), \" specifies the global variable name to use within web browsers.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"globalObject\"), \" sets the global fallback object. The default is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"window\"), \", which is not defined in commonjs environments. Setting the global fallback object to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"this\"), \" generates a umd package that supports both commonjs and web browser environments.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"module.rules\"), \": In this setup, webpack uses babel to transpile ES2015 code to the more widely supported ES5 syntax.\")), mdx(\"h3\", null, \"package.json\"), mdx(\"p\", null, \"Add the following to package.json\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n  \\\"main\\\": \\\"./dist/umd/index.js\\\",\\n  \\\"module\\\": \\\"./dist/esm/index.js\\\",\\n  \\\"types\\\": \\\"./dist/typings/index.d.ts\\\",\\n  \\\"scripts\\\": {\\n    \\\"test\\\": \\\"echo \\\\\\\"Error: no test specified\\\\\\\" && exit 1\\\",\\n    \\\"build\\\": \\\"webpack\\\",\\n    \\\"prebuild\\\": \\\"tsc\\\"\\n  },\\n  \\\"devDependencies\\\": {\\n    \\\"babel-core\\\": \\\"^6.26.0\\\",\\n    \\\"babel-loader\\\": \\\"^7.1.4\\\",\\n    \\\"typescript\\\": \\\"^2.7.2\\\",\\n    \\\"webpack\\\": \\\"^4.1.1\\\",\\n    \\\"webpack-cli\\\": \\\"^2.0.11\\\"\\n  }\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"main\"), \" specifies the location of the umd package. Commonjs environments use this as the main entry point to the library.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"module\"), \" specifies the location of the main ES2015 module. Consuming packages that use webpack or rollup will use this as the main entry point to the library and will eliminate unused (dead) code when bundling the library.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"types\"), \" specifies the location of type definition files. Type definition files provide code intellisense and autocompletion support to TypeScript developers using the library.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"scripts.build\"), \" runs \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"webpack\"), \", transpiling ES2015 modules to an ES5 umd package.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"scripts.prebuild\"), \" runs \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tsc\"), \", compiling TypeScript to ES2015 modules. This command automatically runs prior to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"npm run build\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"devDependencies\"), \" lists the minimal set of packages needed to build both ES2015 modules and a umd package. Don't forget to run \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"npm install\"), \".\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Build\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, \"$ npm run build\\n\")), mdx(\"p\", null, \"Outputs\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/npm-build.png\",\n    \"alt\": \"npm-build\"\n  })), mdx(\"hr\", null), mdx(\"h2\", null, \"Consume the built code\"), mdx(\"h3\", null, \"Web Browsers via script tags\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-html\"\n  }, \"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <meta charset=\\\"UTF-8\\\" />\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" />\\n    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"ie=edge\\\" />\\n    <script src=\\\"./path/to/dist/umd/index.js\\\"></script>\\n    <script>\\n      // webpack exposes the library as a global, myLibrary\\n      myLibrary.sayHello(\\\"World\\\");\\n    </script>\\n  </head>\\n  <body></body>\\n</html>\\n\")), mdx(\"h3\", null, \"commonjs (Node)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var myLibrary = require(\\\"myLibrary\\\");\\n\\nmyLibrary.sayHello(\\\"World\\\");\\n\")), mdx(\"h3\", null, \"ES modules\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"import { sayHello } from \\\"myLibrary/esm/sayHello\\\";\\n\\nsayHello(\\\"World\\\");\\n\")), mdx(\"p\", null, \"Developers using webpack do not have to specify ES module paths. Webpack will automatically use the ES modules based on the module path specified in package.json.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"webpack\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"import { sayHello } from \\\"myLibrary\\\";\\n\\nsayHello(\\\"World\\\");\\n\")));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<h2>Problem</h2><p>You&#x27;ve written a TypeScript library. Now what? Time to publish, of course. But how? Do you publish it as a TypeScript module or compile it to JavaScript? Should it run in browser or Node.js? Or both? What about ES5 versus ES6 or ESNext? And don&#x27;t forget, some people prefer AMD modules.</p><p>In this article, I address all of these concerns and more. I will show you how to publish a TypeScript library to a broad audience. Publishing a TypeScript library can be complicated, but it doesn&#x27;t have to be.</p><h2>TLDR</h2><p>Use tsc to compile TypeScript source code to ES modules. Use webpack + babel to transpile ES modules to a umd package. Providing ES modules and a umd package supports a larger developer community.</p><hr/><h2>Solution</h2><p>A two-step build process.</p><ol><li>Compile TypeScript source code to ES modules using <code>tsc</code>, the TypeScript compiler.</li><li>Bundle ES modules into a single umd module using webpack and babel.</li></ol><hr/><h2>Why</h2><p>Providing both ES modules and a umd package gives developers options. Those working in modern ES2015+ environments can use the ES modules while the umd package supports those working in commonjs or web browser environments. Plus, modern build tools, such as Webpack and rollup, take advantage of ES modules. Build tools will parse, traverse and eliminate unused (dead) code of ES module dependencies.</p><hr/><h2>Why Webpack</h2><p>Unfortunately, the <a href=\"https://github.com/Microsoft/TypeScript/issues/8436\">TypeScript compiler does not support global fallbacks when compiling to umd</a>. In short, umd packages produced by TypeScript do not support web browsers. Webpack, on the other hand, builds umd packages that support web browsers along with commonjs and amd environments.</p><hr/><h2>Why Babel</h2><p>To transpile ES2015 to the more widely supported ES5.</p><hr/><h2>Is Compilation Necessary</h2><p>What about writing TypeScript libraries for TypeScript developers? Is a build process necessary?</p><p>Yes. TypeScript does not compile dependencies (packages listed in node_modules). TypeScript libraries need to be compiled to JavaScript before publishing, even if the intended audience is TypeScript developers.</p><hr/><h2>Project Structure</h2><pre><code class=\"language-asciidoc\">Project/\n|-- src/\n    |-- sayHello.ts\n    |-- index.ts\n|-- tsconfig.json\n|-- webpack.config.js\n|-- package.json\n</code></pre><h3>sayHello.ts</h3><p>A simple function to say hello! This is the only functionality of my awesome library.</p><pre><code class=\"language-js\">export function sayHello(name: string): void {\n  console.log(`Hello, ${name}`);\n}\n</code></pre><h3>index.ts</h3><p>This is the main entry point to the library and, as such, exposes the public API.</p><pre><code class=\"language-js\">export { sayHello } from &quot;./sayHello&quot;;\n</code></pre><h3>tsconfig.json</h3><p>The following options instruct the TypeScript compiler to output ES2015 modules.</p><pre><code class=\"language-json\">{\n  &quot;compilerOptions&quot;: {\n    /* Basic Options */\n    &quot;target&quot;: &quot;ES2015&quot; /* Build to ES2015 */,\n    &quot;module&quot;: &quot;ES2015&quot; /* using ES2015 modules */,\n    &quot;lib&quot;: [&quot;es2015&quot;, &quot;dom&quot;] /* Using ES2015 features and DOM APIs  */,\n    &quot;declaration&quot;: true /* Generates corresponding&#x27;.d.ts&#x27; files. */,\n    &quot;declarationDir&quot;: &quot;./dist/typings/&quot; /* build &#x27;.d.ts&#x27; files to ./dist/typeings */,\n    &quot;outDir&quot;: &quot;./dist/esm/&quot; /* build to ./dist/esm/ */\n  },\n  &quot;files&quot;: [&quot;./src/index.ts&quot;],\n  &quot;include&quot;: [&quot;./src/**/*.ts&quot;]\n}\n</code></pre><ul><li><strong>declarations</strong>: set to true, <code>tsc</code> outputs type definition files which, in turn, provides code intellisense support to TypeScript developers using the library.</li><li><strong>files</strong> specifies which files to compile. In this case, the main entry point to the library is listed. Compiling the main entry point, index.ts, compiles the rest of the library through dependencies.</li></ul><h3>webpack.config.js</h3><p>Webpack bundles ES modules outputted by <code>tsc</code> as a single umd package, targeting ES5. Developers can load the umd package within web browsers, via a script tag, or within commonjs or amd environments.</p><pre><code class=\"language-js\">const path = require(&quot;path&quot;);\n\nmodule.exports = (env, argv) =&gt; {\n  return {\n    entry: {\n      index: path.resolve(__dirname, &quot;./dist/esm/index.js&quot;)\n    },\n    output: {\n      path: path.resolve(__dirname, &quot;./dist/umd&quot;), // builds to ./dist/umd/\n      filename: &quot;[name].js&quot;, // index.js\n      library: &quot;myLibrary&quot;, // aka window.myLibrary\n      libraryTarget: &quot;umd&quot;, // supports commonjs, amd and web browsers\n      globalObject: &quot;this&quot;\n    },\n    module: {\n      rules: [{ test: /\\.t|js$/, use: &quot;babel-loader&quot; }]\n    }\n  };\n};\n</code></pre><ul><li><strong>entry</strong> specifies the entry point to the library. In this setup, webpack transpiles ES2015 to ES5 and does not compile TypeScript source code. For this reason, the file outputted by <code>tsc</code>, which is an ES2015 module, is specified as the input for webpack.</li><li><strong>library</strong> specifies the global variable name to use within web browsers.</li><li><strong>globalObject</strong> sets the global fallback object. The default is <code>window</code>, which is not defined in commonjs environments. Setting the global fallback object to <code>this</code> generates a umd package that supports both commonjs and web browser environments.</li><li><strong>module.rules</strong>: In this setup, webpack uses babel to transpile ES2015 code to the more widely supported ES5 syntax.</li></ul><h3>package.json</h3><p>Add the following to package.json</p><pre><code class=\"language-json\">{\n  &quot;main&quot;: &quot;./dist/umd/index.js&quot;,\n  &quot;module&quot;: &quot;./dist/esm/index.js&quot;,\n  &quot;types&quot;: &quot;./dist/typings/index.d.ts&quot;,\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;build&quot;: &quot;webpack&quot;,\n    &quot;prebuild&quot;: &quot;tsc&quot;\n  },\n  &quot;devDependencies&quot;: {\n    &quot;babel-core&quot;: &quot;^6.26.0&quot;,\n    &quot;babel-loader&quot;: &quot;^7.1.4&quot;,\n    &quot;typescript&quot;: &quot;^2.7.2&quot;,\n    &quot;webpack&quot;: &quot;^4.1.1&quot;,\n    &quot;webpack-cli&quot;: &quot;^2.0.11&quot;\n  }\n}\n</code></pre><ul><li><strong>main</strong> specifies the location of the umd package. Commonjs environments use this as the main entry point to the library.</li><li><strong>module</strong> specifies the location of the main ES2015 module. Consuming packages that use webpack or rollup will use this as the main entry point to the library and will eliminate unused (dead) code when bundling the library.</li><li><strong>types</strong> specifies the location of type definition files. Type definition files provide code intellisense and autocompletion support to TypeScript developers using the library.</li><li><strong>scripts.build</strong> runs <code>webpack</code>, transpiling ES2015 modules to an ES5 umd package.</li><li><strong>scripts.prebuild</strong> runs <code>tsc</code>, compiling TypeScript to ES2015 modules. This command automatically runs prior to <code>npm run build</code>.</li><li><strong>devDependencies</strong> lists the minimal set of packages needed to build both ES2015 modules and a umd package. Don&#x27;t forget to run <code>npm install</code>.</li></ul><hr/><h2>Build</h2><pre><code class=\"language-shell\">$ npm run build\n</code></pre><p>Outputs</p><p><img src=\"/media/npm-build.png\" alt=\"npm-build\"/></p><hr/><h2>Consume the built code</h2><h3>Web Browsers via script tags</h3><pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;script src=&quot;./path/to/dist/umd/index.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n      // webpack exposes the library as a global, myLibrary\n      myLibrary.sayHello(&quot;World&quot;);\n    &lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h3>commonjs (Node)</h3><pre><code class=\"language-js\">var myLibrary = require(&quot;myLibrary&quot;);\n\nmyLibrary.sayHello(&quot;World&quot;);\n</code></pre><h3>ES modules</h3><pre><code class=\"language-js\">import { sayHello } from &quot;myLibrary/esm/sayHello&quot;;\n\nsayHello(&quot;World&quot;);\n</code></pre><p>Developers using webpack do not have to specify ES module paths. Webpack will automatically use the ES modules based on the module path specified in package.json.</p><p><strong>webpack</strong></p><pre><code class=\"language-js\">import { sayHello } from &quot;myLibrary&quot;;\n\nsayHello(&quot;World&quot;);\n</code></pre>","scope":{}},"frontMatter":{"title":"Authoring TypeScript Libraries","date":"2018-03-16","template":"post","published":true,"slug":"authoring-typescript-libraries","category":"TypeScript","tags":["TypeScript"],"description":"You've written a TypeScript library. Now what? Time to publish, of course. But how? Do you publish it as a TypeScript module or compile it to JavaScript? Should it run in browser or Node.js, or both? What about ES5  versus ES6 or ESNext? And don't forget, some people prefer AMD modules."}},"__N_SSG":true}