{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"This article explores data-binding in Blazor 0.7.0\")), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"The source code for this article can be found \", mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://github.com/dworthen/BlazorStateManagement/tree/part-01-data-binding\"\n  }, \"here\"), \".\"))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"This article is part of a Blazor state management exploration series.\")), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Blazor State Management Part I - Data-Binding\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/posts/blazor-state-management-2-event-delegation\"\n  }, \"Blazor State Management Part II - Event Delegation\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/posts/blazor-state-management-3-cascading-parameters\"\n  }, \"Blazor State Management Part III - Cascading Parameters\"))), mdx(\"hr\", null), mdx(\"p\", null, \"MVVM (Model-View-ViewModel) is a UI design pattern that separates the data layer, model, from the presentation layer, view. The pattern bridges the two layers with the ViewModel which is responsible for converting the model into a view-friendly form and for relaying view-driven updates back to the model.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/mvvm-concrete.png\",\n    \"alt\": \"MVVM Diagram\"\n  })), mdx(\"p\", null, \"An important part of the MVVM pattern is the communication between the view and ViewModel. When the ViewModel updates data the view automatically updates to reflect the changes. The opposite is also true. When the view updates data through user interactions, the ViewModel references the most up-to-date data. This is known as data-binding.\"), mdx(\"p\", null, \"In short, data-binding means that the view always reflects the current ViewModel and the ViewModel stays in sync with updates that occur in the view, user-driven or otherwise.\"), mdx(\"p\", null, \"Here is an example of data-binding from the Blazor documentation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"<input type=\\\"checkbox\\\" class=\\\"form-check-input\\\" id=\\\"italicsCheck\\\" bind=\\\"@_italicsCheck\\\" />\\nCurrent Value: @_italicsCheck\\n\\n@functions {\\n    private bool _italicsCheck { get; set; } = false;\\n}\\n\")), mdx(\"p\", null, \"The above is a simple component. The properties defined in the functions section act as our ViewModel and are accessible to the above HTML, the view, through razor syntax. In this case, the view displays a checked checkbox when the ViewModel's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_italicsCheck\"), \" is true. Furthermore, the value stored in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_italicsCheck\"), \" updates as users toggle the checkbox in the UI to match the new toggled state. This functionality, data-binding, is achieved with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bind\"), \" attribute.\"), mdx(\"p\", null, \"Two-way data-binding out of the box! So Blazor supports the MVVM design pattern, right? Not quite. Let's examine what happens when data is used across components.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* UpdateMessage.cshtml *@\\n<div>UpdateMessage Component Current Value: @Message</div>\\n\\n<div>\\n    <input type=\\\"text\\\" bind=\\\"@Message\\\" />\\n</div>\\n\\n@functions {\\n    [Parameter] string Message { get; set; }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* DisplayMessage.cshtml *@\\n<div>Display Message Component Current Value: @Message</div>\\n\\n@functions {\\n    [Parameter] string Message { get; set; }\\n}\\n\")), mdx(\"p\", null, \"And update \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.cshtml\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* index.cshtml *@\\n@page \\\"/\\\"\\n\\n<DisplayMessage Message=\\\"@Message\\\"></DisplayMessage>\\n<UpdateMessage Message=\\\"@Message\\\"></UpdateMessage>\\n\\n@functions {\\n    private string Message { get; set; } = \\\"Hello World\\\";\\n}\\n\")), mdx(\"p\", null, \"Now, two components are using the same data. Let's see what happens when we update the message in UpdateMessage. Do updates propagate to the DisplayMessage component?\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/data-bind-1.png\",\n    \"alt\": \"data-binding a string\"\n  })), mdx(\"p\", null, \"Unfortunately, no. Data-binding is limited to the current component and child components. But wait! Like two-way binding on input tags, Blazor supports two-way binding on custom component parameters using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bind-\"), \" prefix attribute. Let's implement that now.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* index.cshtml *@\\n...\\n<DisplayMessage bind-Message=\\\"@Message\\\"></DisplayMessage>\\n<UpdateMessage bind-Message=\\\"@Message\\\"></UpdateMessage>\\n...\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bind-\"), \" prefix allows one to bind data to custom-component parameters. Before refreshing the application, we need to add the following \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Action\"), \" parameter to UpdateMessage and DisplayMessage.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* DisplayMessage.cshtml and UpdateMessage.cshtml *@\\n...\\n@functions {\\n    ...\\n    [Parameter] Action<string> MessageChanged { get; set; }\\n}\\n\")), mdx(\"p\", null, \"We will examine how this works in a future article. For now, cross your fingers!\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/data-bind-2.png\",\n    \"alt\": \"data-binding with bind attribute\"\n  })), mdx(\"p\", null, \"No luck! Surely, the issue is that we are sharing a string across components. Passing a string is to pass by value. So each component is receiving its own copy of the string. AHA! Let's try using a POCO as our state object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* Person.cs *@\\npublic class Person\\n{\\n    public string Name { get; set; }\\n}\\n\")), mdx(\"p\", null, \"And repeat the same pattern from before...\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* DisplayPerson *@\\n<div>DisplayPerson Component - Person's Name: @person.Name</div>\\n\\n@functions {\\n    [Parameter] Person person { get; set; }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* UpdatePerson Component *@\\n<div>UpdatePerson Component - Person's Name: @person.Name</div>\\n\\n<div>\\n    <input type=\\\"text\\\" bind=\\\"@person.Name\\\" />\\n</div>\\n\\n@functions {\\n    [Parameter] Person person { get; set; }\\n}\\n\")), mdx(\"p\", null, \"Let's not forget to update \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.cshtml\"), \" to use the new Person components.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* index.cshtml *@\\n...\\n<DisplayPerson person=\\\"@person\\\"></DisplayPerson>\\n<UpdatePerson person=\\\"@person\\\"></UpdatePerson>\\n\\n@functions {\\n    ...\\n    private Person person { get; set; } = new Person { Name = \\\"Derek\\\" };\\n}\\n\")), mdx(\"p\", null, \"Refreshing our browser we get\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/data-binding-with-poco.png\",\n    \"alt\": \"Data-binding with poco\"\n  })), mdx(\"p\", null, \"Don't panic! Hope is not lost. Instead of relying on Blazor's data-binding let's try responding to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onchange\"), \" event manually.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* UpdatePerson.cshtml *@\\n...\\n    <input type=\\\"text\\\" value=\\\"@person.Name\\\" onchange=\\\"@OnChange\\\" />\\n...\\n@functions {\\n    ...\\n    private void OnChange(UIChangeEventArgs e)\\n    {\\n        person.Name = (string)e.Value;\\n    }\\n}\\n\")), mdx(\"p\", null, \"If you refresh the browser, you will see that we still have the same functionality. Well, we didn't break anything. We still have component-scoped data-binding. Why use an event listener instead of bind? Using an event listener allows us to have side effects, such as calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StateHasChanged\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* UpdatePerson.cshtml *@\\nprivate void OnChange(UIChangeEventArgs e)\\n{\\n    person.Name = (string)e.Value;\\n    StateHasChanged();\\n}\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StateHasChanged\"), \", if you haven't guessed, is a Blazor function that tells the system that the state has changed which, in turn, triggers a rerender. Blazor renders UI similar to many popular JS frameworks. It maintains a virtual dom. When a rerender occurs, Blazor generates a new virtual dom, diffs it with the previous virtual dom and then minimally updates the real dom.\"), mdx(\"p\", null, \"Maybe, just maybe, manually calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StateHasChanged\"), \" causes Blazor to rerender and diff the entire virtual dom and not just the local component dom. And...\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/data-binding-with-satehaschanged.png\",\n    \"alt\": \"Data-binding with statehaschanged\"\n  })), mdx(\"p\", null, \"Turns out, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StateHasChanged\"), \" is scoped to the current component and child components. No different from bind.\"), mdx(\"p\", null, \"What gives? DisplayPerson and UpdatePerson receive the same Person object. It is an object! It has to be passed by reference, right? This is true. DisplayPerson and UpdatePerson receive a reference to the same object. The problem lies in how rerendering works in Blazor.\"), mdx(\"p\", null, \"Let's prove that the shortcoming lies within the rendering mechanism. Add the following code to DisplayPerson\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"...\\n@functions {\\n...\\n    protected async override Task OnInitAsync()\\n        {\\n            await base.OnInitAsync();\\n            System.Timers.Timer timer = new System.Timers.Timer(10000);\\n            await Task.Delay(6000);\\n            StateHasChanged();\\n        }\\n...\\n}\\n\")), mdx(\"p\", null, \"After 6 seconds, DisplayPerson calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StatehasChanged\"), \", triggering a rerender. This should give us enough time to load the page, update the state within the UpdatePerson component and wait and see if DisplayPerson will display the updated name after StateHasChanged has been called. Go quick. You have 6 seconds. If all goes well, DisplayPerson, after 6 seconds, should display the updated name since it is referencing the same object.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/data-binding-with-a-delay.gif\",\n    \"alt\": \"Data-binding with a delay\"\n  })), mdx(\"p\", null, \"Notice that the name is updating to match user input\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"In summary, Blazor supports component-based data-binding, a process for keeping the ViewModel and view in sync. Data-binding is component based and will not work across components. In future articles, I will examine methods for sharing data across components and ensuring components use and reflect the most up-to-date data.\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<blockquote><p><strong>This article explores data-binding in Blazor 0.7.0</strong></p><p><strong>The source code for this article can be found <a href=\"https://github.com/dworthen/BlazorStateManagement/tree/part-01-data-binding\">here</a>.</strong></p></blockquote><p><strong>This article is part of a Blazor state management exploration series.</strong></p><ol><li>Blazor State Management Part I - Data-Binding</li><li><a href=\"/posts/blazor-state-management-2-event-delegation\">Blazor State Management Part II - Event Delegation</a></li><li><a href=\"/posts/blazor-state-management-3-cascading-parameters\">Blazor State Management Part III - Cascading Parameters</a></li></ol><hr/><p>MVVM (Model-View-ViewModel) is a UI design pattern that separates the data layer, model, from the presentation layer, view. The pattern bridges the two layers with the ViewModel which is responsible for converting the model into a view-friendly form and for relaying view-driven updates back to the model.</p><p><img src=\"/media/mvvm-concrete.png\" alt=\"MVVM Diagram\"/></p><p>An important part of the MVVM pattern is the communication between the view and ViewModel. When the ViewModel updates data the view automatically updates to reflect the changes. The opposite is also true. When the view updates data through user interactions, the ViewModel references the most up-to-date data. This is known as data-binding.</p><p>In short, data-binding means that the view always reflects the current ViewModel and the ViewModel stays in sync with updates that occur in the view, user-driven or otherwise.</p><p>Here is an example of data-binding from the Blazor documentation.</p><pre><code class=\"language-aspnet\">&lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;italicsCheck&quot; bind=&quot;@_italicsCheck&quot; /&gt;\nCurrent Value: @_italicsCheck\n\n@functions {\n    private bool _italicsCheck { get; set; } = false;\n}\n</code></pre><p>The above is a simple component. The properties defined in the functions section act as our ViewModel and are accessible to the above HTML, the view, through razor syntax. In this case, the view displays a checked checkbox when the ViewModel&#x27;s <code>_italicsCheck</code> is true. Furthermore, the value stored in <code>_italicsCheck</code> updates as users toggle the checkbox in the UI to match the new toggled state. This functionality, data-binding, is achieved with the <code>bind</code> attribute.</p><p>Two-way data-binding out of the box! So Blazor supports the MVVM design pattern, right? Not quite. Let&#x27;s examine what happens when data is used across components.</p><pre><code class=\"language-aspnet\">@* UpdateMessage.cshtml *@\n&lt;div&gt;UpdateMessage Component Current Value: @Message&lt;/div&gt;\n\n&lt;div&gt;\n    &lt;input type=&quot;text&quot; bind=&quot;@Message&quot; /&gt;\n&lt;/div&gt;\n\n@functions {\n    [Parameter] string Message { get; set; }\n}\n</code></pre><pre><code class=\"language-aspnet\">@* DisplayMessage.cshtml *@\n&lt;div&gt;Display Message Component Current Value: @Message&lt;/div&gt;\n\n@functions {\n    [Parameter] string Message { get; set; }\n}\n</code></pre><p>And update <code>index.cshtml</code></p><pre><code class=\"language-aspnet\">@* index.cshtml *@\n@page &quot;/&quot;\n\n&lt;DisplayMessage Message=&quot;@Message&quot;&gt;&lt;/DisplayMessage&gt;\n&lt;UpdateMessage Message=&quot;@Message&quot;&gt;&lt;/UpdateMessage&gt;\n\n@functions {\n    private string Message { get; set; } = &quot;Hello World&quot;;\n}\n</code></pre><p>Now, two components are using the same data. Let&#x27;s see what happens when we update the message in UpdateMessage. Do updates propagate to the DisplayMessage component?</p><p><img src=\"/media/data-bind-1.png\" alt=\"data-binding a string\"/></p><p>Unfortunately, no. Data-binding is limited to the current component and child components. But wait! Like two-way binding on input tags, Blazor supports two-way binding on custom component parameters using the <code>bind-</code> prefix attribute. Let&#x27;s implement that now.</p><pre><code class=\"language-aspnet\">@* index.cshtml *@\n...\n&lt;DisplayMessage bind-Message=&quot;@Message&quot;&gt;&lt;/DisplayMessage&gt;\n&lt;UpdateMessage bind-Message=&quot;@Message&quot;&gt;&lt;/UpdateMessage&gt;\n...\n</code></pre><p>The <code>bind-</code> prefix allows one to bind data to custom-component parameters. Before refreshing the application, we need to add the following <code>Action</code> parameter to UpdateMessage and DisplayMessage.</p><pre><code class=\"language-aspnet\">@* DisplayMessage.cshtml and UpdateMessage.cshtml *@\n...\n@functions {\n    ...\n    [Parameter] Action&lt;string&gt; MessageChanged { get; set; }\n}\n</code></pre><p>We will examine how this works in a future article. For now, cross your fingers!</p><p><img src=\"/media/data-bind-2.png\" alt=\"data-binding with bind attribute\"/></p><p>No luck! Surely, the issue is that we are sharing a string across components. Passing a string is to pass by value. So each component is receiving its own copy of the string. AHA! Let&#x27;s try using a POCO as our state object.</p><pre><code class=\"language-aspnet\">@* Person.cs *@\npublic class Person\n{\n    public string Name { get; set; }\n}\n</code></pre><p>And repeat the same pattern from before...</p><pre><code class=\"language-aspnet\">@* DisplayPerson *@\n&lt;div&gt;DisplayPerson Component - Person&#x27;s Name: @person.Name&lt;/div&gt;\n\n@functions {\n    [Parameter] Person person { get; set; }\n}\n</code></pre><pre><code class=\"language-aspnet\">@* UpdatePerson Component *@\n&lt;div&gt;UpdatePerson Component - Person&#x27;s Name: @person.Name&lt;/div&gt;\n\n&lt;div&gt;\n    &lt;input type=&quot;text&quot; bind=&quot;@person.Name&quot; /&gt;\n&lt;/div&gt;\n\n@functions {\n    [Parameter] Person person { get; set; }\n}\n</code></pre><p>Let&#x27;s not forget to update <code>index.cshtml</code> to use the new Person components.</p><pre><code class=\"language-aspnet\">@* index.cshtml *@\n...\n&lt;DisplayPerson person=&quot;@person&quot;&gt;&lt;/DisplayPerson&gt;\n&lt;UpdatePerson person=&quot;@person&quot;&gt;&lt;/UpdatePerson&gt;\n\n@functions {\n    ...\n    private Person person { get; set; } = new Person { Name = &quot;Derek&quot; };\n}\n</code></pre><p>Refreshing our browser we get</p><p><img src=\"/media/data-binding-with-poco.png\" alt=\"Data-binding with poco\"/></p><p>Don&#x27;t panic! Hope is not lost. Instead of relying on Blazor&#x27;s data-binding let&#x27;s try responding to the <code>onchange</code> event manually.</p><pre><code class=\"language-aspnet\">@* UpdatePerson.cshtml *@\n...\n    &lt;input type=&quot;text&quot; value=&quot;@person.Name&quot; onchange=&quot;@OnChange&quot; /&gt;\n...\n@functions {\n    ...\n    private void OnChange(UIChangeEventArgs e)\n    {\n        person.Name = (string)e.Value;\n    }\n}\n</code></pre><p>If you refresh the browser, you will see that we still have the same functionality. Well, we didn&#x27;t break anything. We still have component-scoped data-binding. Why use an event listener instead of bind? Using an event listener allows us to have side effects, such as calling <code>StateHasChanged</code>.</p><pre><code class=\"language-aspnet\">@* UpdatePerson.cshtml *@\nprivate void OnChange(UIChangeEventArgs e)\n{\n    person.Name = (string)e.Value;\n    StateHasChanged();\n}\n</code></pre><p><code>StateHasChanged</code>, if you haven&#x27;t guessed, is a Blazor function that tells the system that the state has changed which, in turn, triggers a rerender. Blazor renders UI similar to many popular JS frameworks. It maintains a virtual dom. When a rerender occurs, Blazor generates a new virtual dom, diffs it with the previous virtual dom and then minimally updates the real dom.</p><p>Maybe, just maybe, manually calling <code>StateHasChanged</code> causes Blazor to rerender and diff the entire virtual dom and not just the local component dom. And...</p><p><img src=\"/media/data-binding-with-satehaschanged.png\" alt=\"Data-binding with statehaschanged\"/></p><p>Turns out, <code>StateHasChanged</code> is scoped to the current component and child components. No different from bind.</p><p>What gives? DisplayPerson and UpdatePerson receive the same Person object. It is an object! It has to be passed by reference, right? This is true. DisplayPerson and UpdatePerson receive a reference to the same object. The problem lies in how rerendering works in Blazor.</p><p>Let&#x27;s prove that the shortcoming lies within the rendering mechanism. Add the following code to DisplayPerson</p><pre><code class=\"language-aspnet\">...\n@functions {\n...\n    protected async override Task OnInitAsync()\n        {\n            await base.OnInitAsync();\n            System.Timers.Timer timer = new System.Timers.Timer(10000);\n            await Task.Delay(6000);\n            StateHasChanged();\n        }\n...\n}\n</code></pre><p>After 6 seconds, DisplayPerson calls <code>StatehasChanged</code>, triggering a rerender. This should give us enough time to load the page, update the state within the UpdatePerson component and wait and see if DisplayPerson will display the updated name after StateHasChanged has been called. Go quick. You have 6 seconds. If all goes well, DisplayPerson, after 6 seconds, should display the updated name since it is referencing the same object.</p><p><img src=\"/media/data-binding-with-a-delay.gif\" alt=\"Data-binding with a delay\"/></p><p>Notice that the name is updating to match user input</p><hr/><h2>Conclusion</h2><p>In summary, Blazor supports component-based data-binding, a process for keeping the ViewModel and view in sync. Data-binding is component based and will not work across components. In future articles, I will examine methods for sharing data across components and ensuring components use and reflect the most up-to-date data.</p>","scope":{}},"frontMatter":{"template":"post","title":"Blazor State Management Part I - Data-Binding","slug":"blazor-state-management-1-data-binding","published":true,"date":"2019-03-08","description":"Data-Binding. It's the magical glue that binds an application's UI to its business model. Or, more formally, It's a process for updating UI when application state changes and vice versa, keeping the state in sync with changes occurring in the UI. Blazor supports data-binding, but to what extent?","category":"Blazor","tags":["Blazor"]}},"__N_SSG":true}