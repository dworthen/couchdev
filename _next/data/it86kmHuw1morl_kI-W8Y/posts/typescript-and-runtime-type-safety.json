{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I began programming in TypeScript by accident. I was exploring Microsoft's new ASP.NET Core framework and before I knew it, I was writing code in TypeScript.\"), mdx(\"p\", null, \"It wasn't my fault. My IDE of choice made the decision for me, without my consent. Visual Studio had decided to scaffold out a project with TypeScript. I thought, \\\"why not?\\\". After all, learning TypeScript was a longtime desire of mine and a chore I put off for long enough. It was time to learn TypeScript.\"), mdx(\"p\", null, \"I was immediately drawn to the type system. The compiler provides type safety and valuable feedback. Take the following code for example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-TypeScript\"\n  }, \"export function add(a: number, b: number): number {\\n    return a + b;\\n}\\n\")), mdx(\"p\", null, \"Valid TypeScript. Now let's call, or should I say miscall, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-TypeScript\"\n  }, \"add('Hello', { name: \\\"World\\\" });\\n\")), mdx(\"p\", null, \"Not so valid. Don't be mistaken, this is valid JavaScript but not valid TypeScript. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'Hello'\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{ name: \\\"World\\\" }\"), \" are invalid arguments for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" since they are not numbers. The compiler will inform us of this blunder.\"), mdx(\"p\", null, \"Writing application code in TypeScript adds type safety, a great benefit to developers. Editing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" to accept strings instead of numbers will cause the compiler to explode. That is until we update all calls of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" to use strings. A valuable feedback loop useful for refactoring. The compiler is the first line of defense.\"), mdx(\"p\", null, \"Writing reusable JavaScript libraries in TypeScript is a different matter. What if we were to package and distribute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" as a JavaScript library? The following is the compiled JavaScript version of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-JavaScript\"\n  }, \"export function add(a, b) {\\n    return a + b;\\n}\\n\")), mdx(\"p\", null, \"That's right. TypeScript's compiler removes all information about types. This makes sense. TypeScript compiles to valid JavaScript, which does not have a static type system. Though it provides compile-time type safety, TypeScript \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"does not\"), \" provide runtime type safety.\"), mdx(\"p\", null, \"Compilation removes type information and restraints on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \". Developers using the compiled library may call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" with strings instead of numbers. Nothing prevents them from doing so.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Solution\"), mdx(\"p\", null, \"As always with library development, consider end users and write unit tests for all use cases. On top of unit tests, consider writing runtime type checks. This will prevent misuse of code or provide relevant feedback when misuse occurs.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-TypeScript\"\n  }, \"export function add(a: number, b: number): number {\\n    if(typeof a !== 'number') {\\n        throw new TypeError('....');\\n    }\\n    if(typeof b !== 'number') {\\n        throw new TypeError('....');\\n    }\\n    return a + b;\\n}\\n\")), mdx(\"p\", null, \"The above is still valid, and beautiful, TypeScript. The compiler has no problems with the extra type guards.\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>I began programming in TypeScript by accident. I was exploring Microsoft&#x27;s new ASP.NET Core framework and before I knew it, I was writing code in TypeScript.</p><p>It wasn&#x27;t my fault. My IDE of choice made the decision for me, without my consent. Visual Studio had decided to scaffold out a project with TypeScript. I thought, &quot;why not?&quot;. After all, learning TypeScript was a longtime desire of mine and a chore I put off for long enough. It was time to learn TypeScript.</p><p>I was immediately drawn to the type system. The compiler provides type safety and valuable feedback. Take the following code for example:</p><pre><code class=\"language-TypeScript\">export function add(a: number, b: number): number {\n    return a + b;\n}\n</code></pre><p>Valid TypeScript. Now let&#x27;s call, or should I say miscall, <code>add</code>.</p><pre><code class=\"language-TypeScript\">add(&#x27;Hello&#x27;, { name: &quot;World&quot; });\n</code></pre><p>Not so valid. Don&#x27;t be mistaken, this is valid JavaScript but not valid TypeScript. <code>&#x27;Hello&#x27;</code> and <code>{ name: &quot;World&quot; }</code> are invalid arguments for <code>add</code> since they are not numbers. The compiler will inform us of this blunder.</p><p>Writing application code in TypeScript adds type safety, a great benefit to developers. Editing <code>add</code> to accept strings instead of numbers will cause the compiler to explode. That is until we update all calls of <code>add</code> to use strings. A valuable feedback loop useful for refactoring. The compiler is the first line of defense.</p><p>Writing reusable JavaScript libraries in TypeScript is a different matter. What if we were to package and distribute <code>add</code> as a JavaScript library? The following is the compiled JavaScript version of <code>add</code>.</p><pre><code class=\"language-JavaScript\">export function add(a, b) {\n    return a + b;\n}\n</code></pre><p>That&#x27;s right. TypeScript&#x27;s compiler removes all information about types. This makes sense. TypeScript compiles to valid JavaScript, which does not have a static type system. Though it provides compile-time type safety, TypeScript <strong>does not</strong> provide runtime type safety.</p><p>Compilation removes type information and restraints on <code>add</code>. Developers using the compiled library may call <code>add</code> with strings instead of numbers. Nothing prevents them from doing so.</p><hr/><h2>Solution</h2><p>As always with library development, consider end users and write unit tests for all use cases. On top of unit tests, consider writing runtime type checks. This will prevent misuse of code or provide relevant feedback when misuse occurs.</p><pre><code class=\"language-TypeScript\">export function add(a: number, b: number): number {\n    if(typeof a !== &#x27;number&#x27;) {\n        throw new TypeError(&#x27;....&#x27;);\n    }\n    if(typeof b !== &#x27;number&#x27;) {\n        throw new TypeError(&#x27;....&#x27;);\n    }\n    return a + b;\n}\n</code></pre><p>The above is still valid, and beautiful, TypeScript. The compiler has no problems with the extra type guards.</p>","scope":{}},"frontMatter":{"template":"post","title":"TypeScript and Runtime Type Safety","slug":"typescript-and-runtime-type-safety","published":true,"date":"2018-05-24","description":"Intellisense, type definitions, tooling, and documentation. A few of the benefits that follow from TypeScript's compile-time static type system but it's not all good news. There are some drawbacks. For starters, the type checking, and thus type safety, occur at compile time. What about Runtime type safety?","category":"TypeScript","tags":["TypeScript"]}},"__N_SSG":true}