<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/750db2f755193dfeff7f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/750db2f755193dfeff7f.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-6fd6122508a3ecee2da5.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.386717e5d53cbb6c2786.js" as="script"/><link rel="preload" href="/_next/static/chunks/71247caf95475e3ea7f9a0f8a30beb258b23d005.6e2460ecc34e06341fc5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-38d928fb62d663b3f9dd.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bslug%5D-8c30f50305d85407af2b.js" as="script"/></head><body><div id="__next"><div class="sc-1ho0hv8-0 hslvLF"><div><main><div><p>I began programming in TypeScript by accident. I was exploring Microsoft&#x27;s new ASP.NET Core framework and before I knew it, I was writing code in TypeScript.</p><p>It wasn&#x27;t my fault. My IDE of choice made the decision for me, without my consent. Visual Studio had decided to scaffold out a project with TypeScript. I thought, &quot;why not?&quot;. After all, learning TypeScript was a longtime desire of mine and a chore I put off for long enough. It was time to learn TypeScript.</p><p>I was immediately drawn to the type system. The compiler provides type safety and valuable feedback. Take the following code for example:</p><pre><code class="language-TypeScript">export function add(a: number, b: number): number {
    return a + b;
}
</code></pre><p>Valid TypeScript. Now let&#x27;s call, or should I say miscall, <code>add</code>.</p><pre><code class="language-TypeScript">add(&#x27;Hello&#x27;, { name: &quot;World&quot; });
</code></pre><p>Not so valid. Don&#x27;t be mistaken, this is valid JavaScript but not valid TypeScript. <code>&#x27;Hello&#x27;</code> and <code>{ name: &quot;World&quot; }</code> are invalid arguments for <code>add</code> since they are not numbers. The compiler will inform us of this blunder.</p><p>Writing application code in TypeScript adds type safety, a great benefit to developers. Editing <code>add</code> to accept strings instead of numbers will cause the compiler to explode. That is until we update all calls of <code>add</code> to use strings. A valuable feedback loop useful for refactoring. The compiler is the first line of defense.</p><p>Writing reusable JavaScript libraries in TypeScript is a different matter. What if we were to package and distribute <code>add</code> as a JavaScript library? The following is the compiled JavaScript version of <code>add</code>.</p><pre><code class="language-JavaScript">export function add(a, b) {
    return a + b;
}
</code></pre><p>That&#x27;s right. TypeScript&#x27;s compiler removes all information about types. This makes sense. TypeScript compiles to valid JavaScript, which does not have a static type system. Though it provides compile-time type safety, TypeScript <strong>does not</strong> provide runtime type safety.</p><p>Compilation removes type information and restraints on <code>add</code>. Developers using the compiled library may call <code>add</code> with strings instead of numbers. Nothing prevents them from doing so.</p><hr/><h2>Solution</h2><p>As always with library development, consider end users and write unit tests for all use cases. On top of unit tests, consider writing runtime type checks. This will prevent misuse of code or provide relevant feedback when misuse occurs.</p><pre><code class="language-TypeScript">export function add(a: number, b: number): number {
    if(typeof a !== &#x27;number&#x27;) {
        throw new TypeError(&#x27;....&#x27;);
    }
    if(typeof b !== &#x27;number&#x27;) {
        throw new TypeError(&#x27;....&#x27;);
    }
    return a + b;
}
</code></pre><p>The above is still valid, and beautiful, TypeScript. The compiler has no problems with the extra type guards.</p></div></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i \u003c arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i \u003c sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i \u003c sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I began programming in TypeScript by accident. I was exploring Microsoft's new ASP.NET Core framework and before I knew it, I was writing code in TypeScript.\"), mdx(\"p\", null, \"It wasn't my fault. My IDE of choice made the decision for me, without my consent. Visual Studio had decided to scaffold out a project with TypeScript. I thought, \\\"why not?\\\". After all, learning TypeScript was a longtime desire of mine and a chore I put off for long enough. It was time to learn TypeScript.\"), mdx(\"p\", null, \"I was immediately drawn to the type system. The compiler provides type safety and valuable feedback. Take the following code for example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-TypeScript\"\n  }, \"export function add(a: number, b: number): number {\\n    return a + b;\\n}\\n\")), mdx(\"p\", null, \"Valid TypeScript. Now let's call, or should I say miscall, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-TypeScript\"\n  }, \"add('Hello', { name: \\\"World\\\" });\\n\")), mdx(\"p\", null, \"Not so valid. Don't be mistaken, this is valid JavaScript but not valid TypeScript. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'Hello'\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{ name: \\\"World\\\" }\"), \" are invalid arguments for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" since they are not numbers. The compiler will inform us of this blunder.\"), mdx(\"p\", null, \"Writing application code in TypeScript adds type safety, a great benefit to developers. Editing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" to accept strings instead of numbers will cause the compiler to explode. That is until we update all calls of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" to use strings. A valuable feedback loop useful for refactoring. The compiler is the first line of defense.\"), mdx(\"p\", null, \"Writing reusable JavaScript libraries in TypeScript is a different matter. What if we were to package and distribute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" as a JavaScript library? The following is the compiled JavaScript version of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-JavaScript\"\n  }, \"export function add(a, b) {\\n    return a + b;\\n}\\n\")), mdx(\"p\", null, \"That's right. TypeScript's compiler removes all information about types. This makes sense. TypeScript compiles to valid JavaScript, which does not have a static type system. Though it provides compile-time type safety, TypeScript \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"does not\"), \" provide runtime type safety.\"), mdx(\"p\", null, \"Compilation removes type information and restraints on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \". Developers using the compiled library may call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" with strings instead of numbers. Nothing prevents them from doing so.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Solution\"), mdx(\"p\", null, \"As always with library development, consider end users and write unit tests for all use cases. On top of unit tests, consider writing runtime type checks. This will prevent misuse of code or provide relevant feedback when misuse occurs.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-TypeScript\"\n  }, \"export function add(a: number, b: number): number {\\n    if(typeof a !== 'number') {\\n        throw new TypeError('....');\\n    }\\n    if(typeof b !== 'number') {\\n        throw new TypeError('....');\\n    }\\n    return a + b;\\n}\\n\")), mdx(\"p\", null, \"The above is still valid, and beautiful, TypeScript. The compiler has no problems with the extra type guards.\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"\u003cp\u003eI began programming in TypeScript by accident. I was exploring Microsoft\u0026#x27;s new ASP.NET Core framework and before I knew it, I was writing code in TypeScript.\u003c/p\u003e\u003cp\u003eIt wasn\u0026#x27;t my fault. My IDE of choice made the decision for me, without my consent. Visual Studio had decided to scaffold out a project with TypeScript. I thought, \u0026quot;why not?\u0026quot;. After all, learning TypeScript was a longtime desire of mine and a chore I put off for long enough. It was time to learn TypeScript.\u003c/p\u003e\u003cp\u003eI was immediately drawn to the type system. The compiler provides type safety and valuable feedback. Take the following code for example:\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-TypeScript\"\u003eexport function add(a: number, b: number): number {\n    return a + b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eValid TypeScript. Now let\u0026#x27;s call, or should I say miscall, \u003ccode\u003eadd\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-TypeScript\"\u003eadd(\u0026#x27;Hello\u0026#x27;, { name: \u0026quot;World\u0026quot; });\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNot so valid. Don\u0026#x27;t be mistaken, this is valid JavaScript but not valid TypeScript. \u003ccode\u003e\u0026#x27;Hello\u0026#x27;\u003c/code\u003e and \u003ccode\u003e{ name: \u0026quot;World\u0026quot; }\u003c/code\u003e are invalid arguments for \u003ccode\u003eadd\u003c/code\u003e since they are not numbers. The compiler will inform us of this blunder.\u003c/p\u003e\u003cp\u003eWriting application code in TypeScript adds type safety, a great benefit to developers. Editing \u003ccode\u003eadd\u003c/code\u003e to accept strings instead of numbers will cause the compiler to explode. That is until we update all calls of \u003ccode\u003eadd\u003c/code\u003e to use strings. A valuable feedback loop useful for refactoring. The compiler is the first line of defense.\u003c/p\u003e\u003cp\u003eWriting reusable JavaScript libraries in TypeScript is a different matter. What if we were to package and distribute \u003ccode\u003eadd\u003c/code\u003e as a JavaScript library? The following is the compiled JavaScript version of \u003ccode\u003eadd\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-JavaScript\"\u003eexport function add(a, b) {\n    return a + b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat\u0026#x27;s right. TypeScript\u0026#x27;s compiler removes all information about types. This makes sense. TypeScript compiles to valid JavaScript, which does not have a static type system. Though it provides compile-time type safety, TypeScript \u003cstrong\u003edoes not\u003c/strong\u003e provide runtime type safety.\u003c/p\u003e\u003cp\u003eCompilation removes type information and restraints on \u003ccode\u003eadd\u003c/code\u003e. Developers using the compiled library may call \u003ccode\u003eadd\u003c/code\u003e with strings instead of numbers. Nothing prevents them from doing so.\u003c/p\u003e\u003chr/\u003e\u003ch2\u003eSolution\u003c/h2\u003e\u003cp\u003eAs always with library development, consider end users and write unit tests for all use cases. On top of unit tests, consider writing runtime type checks. This will prevent misuse of code or provide relevant feedback when misuse occurs.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-TypeScript\"\u003eexport function add(a: number, b: number): number {\n    if(typeof a !== \u0026#x27;number\u0026#x27;) {\n        throw new TypeError(\u0026#x27;....\u0026#x27;);\n    }\n    if(typeof b !== \u0026#x27;number\u0026#x27;) {\n        throw new TypeError(\u0026#x27;....\u0026#x27;);\n    }\n    return a + b;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above is still valid, and beautiful, TypeScript. The compiler has no problems with the extra type guards.\u003c/p\u003e","scope":{}},"frontMatter":{"template":"post","title":"TypeScript and Runtime Type Safety","slug":"typescript-and-runtime-type-safety","published":true,"date":"2018-05-24","description":"Intellisense, type definitions, tooling, and documentation. A few of the benefits that follow from TypeScript's compile-time static type system but it's not all good news. There are some drawbacks. For starters, the type checking, and thus type safety, occur at compile time. What about Runtime type safety?","category":"TypeScript","tags":["TypeScript"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"typescript-and-runtime-type-safety"},"buildId":"c-PzTcYntvLLEE3J2MI77","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-4a659121523c89b6d810.js"></script><script src="/_next/static/chunks/main-6fd6122508a3ecee2da5.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.386717e5d53cbb6c2786.js" async=""></script><script src="/_next/static/chunks/71247caf95475e3ea7f9a0f8a30beb258b23d005.6e2460ecc34e06341fc5.js" async=""></script><script src="/_next/static/chunks/pages/_app-38d928fb62d663b3f9dd.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-8c30f50305d85407af2b.js" async=""></script><script src="/_next/static/c-PzTcYntvLLEE3J2MI77/_buildManifest.js" async=""></script><script src="/_next/static/c-PzTcYntvLLEE3J2MI77/_ssgManifest.js" async=""></script></body></html>