<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/4c0306d5b03180f9727b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4c0306d5b03180f9727b.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-15cc7adb6c68e37a6c83.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.386717e5d53cbb6c2786.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-bc7fdccc4b180668915c.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bslug%5D-4a2fe920f2221d4f2899.js" as="script"/></head><body><div id="__next"><div class="Layout__StyledMain-sc-1ho0hv8-0 fsweVq"><header class="Header__StyledHeader-wxqfda-0 bIiJxr"><div><h2><a href="/">Couch Dev</a> <small>Prerecorded from my couch, it&#x27;s a dev making sense of dev things!</small></h2></div></header><div><main><div><blockquote><p><strong>This article explores event delegation in Blazor 0.7.0</strong></p><p><strong>The source code for this article can be found <a href="https://github.com/dworthen/BlazorStateManagement/tree/part-02-event-delegation">here</a></strong></p></blockquote><p><strong>This article is part of a Blazor state management exploration series.</strong></p><ol><li><a href="/posts/blazor-state-management-1-data-binding">Blazor State Management Part I - Data-Binding</a></li><li>Blazor State Management Part II - Event Delegation</li><li><a href="/posts/blazor-state-management-3-cascading-parameters">Blazor State Management Part III - Cascading Parameters</a></li></ol><hr/><p><a href="/posts/blazor-state-management-1-data-binding">Previously</a>, we developed a sample application in order to explore data-binding in Blazor. Here is the current component structure of our sample application.</p><p><img src="/media/component-structure.png" alt="data-binding component structure"/></p><p>The index page shares a <code>Person</code> object to two components, <code>DisplayPerson</code> and <code>UpdatePerson</code>. Changes to <code>person</code>  that occur in <code>UpdatePerson</code> do not show up in <code>DisplayPerson</code>. At least, not automatically. This behavior was observed and discussed in the previous article. </p><p>So how does one share objects across components and ensure that components are working with, and reflecting the most up-to-date state? One way to solve this problem is to use event delegation.</p><blockquote><p><strong>Event delegation</strong> refers to the process of using event propagation (bubbling) to handle events at a higher level in the DOM than the element on which the event originated. </p><p><a href="https://learn.jquery.com/events/event-delegation/">https://learn.jquery.com/events/event-delegation/</a></p></blockquote><p>Instead of handling events in <code>UpdatePerson</code>, events are bubbled up to the <code>index</code> page. The <code>index</code> page will handle the event, make changes to <code>person</code> and propagate the changes to child components. <code>UpdatePerson</code> and <code>DisplayPerson</code> in this case. </p><hr/><h2>Event handler</h2><p>Add the following <code>HandleChange</code> method to the <code>index.cshtml</code> page. <code>HandleChange</code> will respond to input changes that occur in <code>UpdatePerson</code>, updating the <code>person</code>&#x27;s name and calling <code>StateHasChanged</code> to rerender the UI.</p><pre><code class="language-aspnet">@* index.cshtml *@
...
@functions {
...
    private void HandleChange (UIChangeEventArgs e)
    {
        person.Name = e.Value.ToString();
        StateHasChanged();
    }
}
</code></pre><hr/><h2>Event Propagation (Bubbling)</h2><p>The <code>HandleChange</code> event handler is in place. Now, we need to change <code>UpdatePerson</code> to bubble onchange events up to <code>index</code>/<code>HandleChange</code>. We can do this by adding a custom component parameter to <code>UpdatePerson</code>.</p><pre><code class="language-apsnet">@* UpdatePerson *@
...
@functions {
    ...
    [Parameter] protected Action&lt;UIChangeEventArgs&gt; CustomOnChange { get; set; }

    private void OnChange(UIChangeEventArgs e)
    {
        CustomOnChange?.Invoke(e);
    }
}
</code></pre><p>The custom parameter, <code>CustomOnChange</code>, is defined as an <code>Action&lt;UIChangeEventArgs&gt;</code>. Actions are methods that except some list of parameters, <code>UIChangeEventArgs</code> in this case, and return nothing (null). Notice that this action defines a method that matches the <code>HandleChange</code> method signature. I think you can see where we are going here. </p><blockquote><p><strong><a href="https://www.codementor.io/aydindev/delegates-func-act-in-c-sharp-du107s5mj">More in-depth guide to Actions</a></strong></p></blockquote><p>The final piece of the puzzle, wiring up the components. Update the <code>index</code> page to pass in <code>HandleChange</code> to <code>UpdatePerson</code>. </p><pre><code class="language-aspnet">@* index.cshtml *@
...
&lt;UpdatePerson person=&quot;@person&quot; 
    CustomOnChange=&quot;@HandleChange&quot;&gt;&lt;/UpdatePerson&gt;
...
</code></pre><p>Essentially, we are exposing the onchange event from <code>UpdatePerson</code> to <code>index</code> as a custom event, <code>CustomOnChange</code>, and handling the event with <code>HandleChange</code>. </p><p>Launching this application and updating the name in the input field will show that <code>DisplayPerson</code> now updates to reflect the current name. Finally, we have a way to share objects across components.</p><hr/><h2>Conclusion</h2><p>We started with one component structure/relationship and, through this article, and minor tweaks, we ended up with</p><p><img src="/media/event-delegation.png" alt="event delegation relationship"/></p><p>Event delegation provides a way to organize components in a way that allows for sharing state across components. The process for using event delegation for this purpose is to 1) identify a parent component that will &quot;own&quot; the data and 2) bubble events/changes from child components up to the parent component, the one that &quot;owns&quot; the data, to handle changes. </p><p>There are some drawbacks to this method of sharing state. For example, how do we handle the following case?</p><p><img src="/media/event-delegation-complicated.png" alt="Event delegation with nested components."/></p><p>In this case, <code>DisplayPerson</code> and <code>UpdatePerson</code> still need access to <code>person</code> but the middle components know nothing about <code>person</code> and don&#x27;t need to. We could update middle components to accept <code>person</code> parameters and pass them through to the child components that need it. We would also need to pass event handlers from the parent component through middle components down to child components. A doable process but messy and cumbersome. We will explore alternative solutions for handling this case in future articles.</p><p>Event delegation is only one of many methods for sharing data across components. We will examine other methods in future articles.</p></div></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i \u003c arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i \u003c sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i \u003c sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"This article explores event delegation in Blazor 0.7.0\")), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"The source code for this article can be found \", mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://github.com/dworthen/BlazorStateManagement/tree/part-02-event-delegation\"\n  }, \"here\")))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"This article is part of a Blazor state management exploration series.\")), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/posts/blazor-state-management-1-data-binding\"\n  }, \"Blazor State Management Part I - Data-Binding\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Blazor State Management Part II - Event Delegation\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/posts/blazor-state-management-3-cascading-parameters\"\n  }, \"Blazor State Management Part III - Cascading Parameters\"))), mdx(\"hr\", null), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/posts/blazor-state-management-1-data-binding\"\n  }, \"Previously\"), \", we developed a sample application in order to explore data-binding in Blazor. Here is the current component structure of our sample application.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/component-structure.png\",\n    \"alt\": \"data-binding component structure\"\n  })), mdx(\"p\", null, \"The index page shares a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" object to two components, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DisplayPerson\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \". Changes to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"person\"), \"  that occur in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \" do not show up in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DisplayPerson\"), \". At least, not automatically. This behavior was observed and discussed in the previous article. \"), mdx(\"p\", null, \"So how does one share objects across components and ensure that components are working with, and reflecting the most up-to-date state? One way to solve this problem is to use event delegation.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Event delegation\"), \" refers to the process of using event propagation (bubbling) to handle events at a higher level in the DOM than the element on which the event originated. \"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://learn.jquery.com/events/event-delegation/\"\n  }, \"https://learn.jquery.com/events/event-delegation/\"))), mdx(\"p\", null, \"Instead of handling events in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \", events are bubbled up to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index\"), \" page. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index\"), \" page will handle the event, make changes to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"person\"), \" and propagate the changes to child components. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DisplayPerson\"), \" in this case. \"), mdx(\"hr\", null), mdx(\"h2\", null, \"Event handler\"), mdx(\"p\", null, \"Add the following \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HandleChange\"), \" method to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.cshtml\"), \" page. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HandleChange\"), \" will respond to input changes that occur in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \", updating the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"person\"), \"'s name and calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StateHasChanged\"), \" to rerender the UI.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* index.cshtml *@\\n...\\n@functions {\\n...\\n    private void HandleChange (UIChangeEventArgs e)\\n    {\\n        person.Name = e.Value.ToString();\\n        StateHasChanged();\\n    }\\n}\\n\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Event Propagation (Bubbling)\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HandleChange\"), \" event handler is in place. Now, we need to change \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \" to bubble onchange events up to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HandleChange\"), \". We can do this by adding a custom component parameter to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-apsnet\"\n  }, \"@* UpdatePerson *@\\n...\\n@functions {\\n    ...\\n    [Parameter] protected Action\u003cUIChangeEventArgs\u003e CustomOnChange { get; set; }\\n\\n    private void OnChange(UIChangeEventArgs e)\\n    {\\n        CustomOnChange?.Invoke(e);\\n    }\\n}\\n\")), mdx(\"p\", null, \"The custom parameter, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CustomOnChange\"), \", is defined as an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Action\u003cUIChangeEventArgs\u003e\"), \". Actions are methods that except some list of parameters, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIChangeEventArgs\"), \" in this case, and return nothing (null). Notice that this action defines a method that matches the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HandleChange\"), \" method signature. I think you can see where we are going here. \"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://www.codementor.io/aydindev/delegates-func-act-in-c-sharp-du107s5mj\"\n  }, \"More in-depth guide to Actions\")))), mdx(\"p\", null, \"The final piece of the puzzle, wiring up the components. Update the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index\"), \" page to pass in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HandleChange\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \". \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* index.cshtml *@\\n...\\n\u003cUpdatePerson person=\\\"@person\\\" \\n    CustomOnChange=\\\"@HandleChange\\\"\u003e\u003c/UpdatePerson\u003e\\n...\\n\")), mdx(\"p\", null, \"Essentially, we are exposing the onchange event from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index\"), \" as a custom event, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CustomOnChange\"), \", and handling the event with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HandleChange\"), \". \"), mdx(\"p\", null, \"Launching this application and updating the name in the input field will show that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DisplayPerson\"), \" now updates to reflect the current name. Finally, we have a way to share objects across components.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"We started with one component structure/relationship and, through this article, and minor tweaks, we ended up with\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/event-delegation.png\",\n    \"alt\": \"event delegation relationship\"\n  })), mdx(\"p\", null, \"Event delegation provides a way to organize components in a way that allows for sharing state across components. The process for using event delegation for this purpose is to 1) identify a parent component that will \\\"own\\\" the data and 2) bubble events/changes from child components up to the parent component, the one that \\\"owns\\\" the data, to handle changes. \"), mdx(\"p\", null, \"There are some drawbacks to this method of sharing state. For example, how do we handle the following case?\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/event-delegation-complicated.png\",\n    \"alt\": \"Event delegation with nested components.\"\n  })), mdx(\"p\", null, \"In this case, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DisplayPerson\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \" still need access to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"person\"), \" but the middle components know nothing about \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"person\"), \" and don't need to. We could update middle components to accept \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"person\"), \" parameters and pass them through to the child components that need it. We would also need to pass event handlers from the parent component through middle components down to child components. A doable process but messy and cumbersome. We will explore alternative solutions for handling this case in future articles.\"), mdx(\"p\", null, \"Event delegation is only one of many methods for sharing data across components. We will examine other methods in future articles.\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003eThis article explores event delegation in Blazor 0.7.0\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eThe source code for this article can be found \u003ca href=\"https://github.com/dworthen/BlazorStateManagement/tree/part-02-event-delegation\"\u003ehere\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e\u003cstrong\u003eThis article is part of a Blazor state management exploration series.\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003ca href=\"/posts/blazor-state-management-1-data-binding\"\u003eBlazor State Management Part I - Data-Binding\u003c/a\u003e\u003c/li\u003e\u003cli\u003eBlazor State Management Part II - Event Delegation\u003c/li\u003e\u003cli\u003e\u003ca href=\"/posts/blazor-state-management-3-cascading-parameters\"\u003eBlazor State Management Part III - Cascading Parameters\u003c/a\u003e\u003c/li\u003e\u003c/ol\u003e\u003chr/\u003e\u003cp\u003e\u003ca href=\"/posts/blazor-state-management-1-data-binding\"\u003ePreviously\u003c/a\u003e, we developed a sample application in order to explore data-binding in Blazor. Here is the current component structure of our sample application.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"/media/component-structure.png\" alt=\"data-binding component structure\"/\u003e\u003c/p\u003e\u003cp\u003eThe index page shares a \u003ccode\u003ePerson\u003c/code\u003e object to two components, \u003ccode\u003eDisplayPerson\u003c/code\u003e and \u003ccode\u003eUpdatePerson\u003c/code\u003e. Changes to \u003ccode\u003eperson\u003c/code\u003e  that occur in \u003ccode\u003eUpdatePerson\u003c/code\u003e do not show up in \u003ccode\u003eDisplayPerson\u003c/code\u003e. At least, not automatically. This behavior was observed and discussed in the previous article. \u003c/p\u003e\u003cp\u003eSo how does one share objects across components and ensure that components are working with, and reflecting the most up-to-date state? One way to solve this problem is to use event delegation.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003eEvent delegation\u003c/strong\u003e refers to the process of using event propagation (bubbling) to handle events at a higher level in the DOM than the element on which the event originated. \u003c/p\u003e\u003cp\u003e\u003ca href=\"https://learn.jquery.com/events/event-delegation/\"\u003ehttps://learn.jquery.com/events/event-delegation/\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eInstead of handling events in \u003ccode\u003eUpdatePerson\u003c/code\u003e, events are bubbled up to the \u003ccode\u003eindex\u003c/code\u003e page. The \u003ccode\u003eindex\u003c/code\u003e page will handle the event, make changes to \u003ccode\u003eperson\u003c/code\u003e and propagate the changes to child components. \u003ccode\u003eUpdatePerson\u003c/code\u003e and \u003ccode\u003eDisplayPerson\u003c/code\u003e in this case. \u003c/p\u003e\u003chr/\u003e\u003ch2\u003eEvent handler\u003c/h2\u003e\u003cp\u003eAdd the following \u003ccode\u003eHandleChange\u003c/code\u003e method to the \u003ccode\u003eindex.cshtml\u003c/code\u003e page. \u003ccode\u003eHandleChange\u003c/code\u003e will respond to input changes that occur in \u003ccode\u003eUpdatePerson\u003c/code\u003e, updating the \u003ccode\u003eperson\u003c/code\u003e\u0026#x27;s name and calling \u003ccode\u003eStateHasChanged\u003c/code\u003e to rerender the UI.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* index.cshtml *@\n...\n@functions {\n...\n    private void HandleChange (UIChangeEventArgs e)\n    {\n        person.Name = e.Value.ToString();\n        StateHasChanged();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003chr/\u003e\u003ch2\u003eEvent Propagation (Bubbling)\u003c/h2\u003e\u003cp\u003eThe \u003ccode\u003eHandleChange\u003c/code\u003e event handler is in place. Now, we need to change \u003ccode\u003eUpdatePerson\u003c/code\u003e to bubble onchange events up to \u003ccode\u003eindex\u003c/code\u003e/\u003ccode\u003eHandleChange\u003c/code\u003e. We can do this by adding a custom component parameter to \u003ccode\u003eUpdatePerson\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-apsnet\"\u003e@* UpdatePerson *@\n...\n@functions {\n    ...\n    [Parameter] protected Action\u0026lt;UIChangeEventArgs\u0026gt; CustomOnChange { get; set; }\n\n    private void OnChange(UIChangeEventArgs e)\n    {\n        CustomOnChange?.Invoke(e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe custom parameter, \u003ccode\u003eCustomOnChange\u003c/code\u003e, is defined as an \u003ccode\u003eAction\u0026lt;UIChangeEventArgs\u0026gt;\u003c/code\u003e. Actions are methods that except some list of parameters, \u003ccode\u003eUIChangeEventArgs\u003c/code\u003e in this case, and return nothing (null). Notice that this action defines a method that matches the \u003ccode\u003eHandleChange\u003c/code\u003e method signature. I think you can see where we are going here. \u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://www.codementor.io/aydindev/delegates-func-act-in-c-sharp-du107s5mj\"\u003eMore in-depth guide to Actions\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eThe final piece of the puzzle, wiring up the components. Update the \u003ccode\u003eindex\u003c/code\u003e page to pass in \u003ccode\u003eHandleChange\u003c/code\u003e to \u003ccode\u003eUpdatePerson\u003c/code\u003e. \u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* index.cshtml *@\n...\n\u0026lt;UpdatePerson person=\u0026quot;@person\u0026quot; \n    CustomOnChange=\u0026quot;@HandleChange\u0026quot;\u0026gt;\u0026lt;/UpdatePerson\u0026gt;\n...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEssentially, we are exposing the onchange event from \u003ccode\u003eUpdatePerson\u003c/code\u003e to \u003ccode\u003eindex\u003c/code\u003e as a custom event, \u003ccode\u003eCustomOnChange\u003c/code\u003e, and handling the event with \u003ccode\u003eHandleChange\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eLaunching this application and updating the name in the input field will show that \u003ccode\u003eDisplayPerson\u003c/code\u003e now updates to reflect the current name. Finally, we have a way to share objects across components.\u003c/p\u003e\u003chr/\u003e\u003ch2\u003eConclusion\u003c/h2\u003e\u003cp\u003eWe started with one component structure/relationship and, through this article, and minor tweaks, we ended up with\u003c/p\u003e\u003cp\u003e\u003cimg src=\"/media/event-delegation.png\" alt=\"event delegation relationship\"/\u003e\u003c/p\u003e\u003cp\u003eEvent delegation provides a way to organize components in a way that allows for sharing state across components. The process for using event delegation for this purpose is to 1) identify a parent component that will \u0026quot;own\u0026quot; the data and 2) bubble events/changes from child components up to the parent component, the one that \u0026quot;owns\u0026quot; the data, to handle changes. \u003c/p\u003e\u003cp\u003eThere are some drawbacks to this method of sharing state. For example, how do we handle the following case?\u003c/p\u003e\u003cp\u003e\u003cimg src=\"/media/event-delegation-complicated.png\" alt=\"Event delegation with nested components.\"/\u003e\u003c/p\u003e\u003cp\u003eIn this case, \u003ccode\u003eDisplayPerson\u003c/code\u003e and \u003ccode\u003eUpdatePerson\u003c/code\u003e still need access to \u003ccode\u003eperson\u003c/code\u003e but the middle components know nothing about \u003ccode\u003eperson\u003c/code\u003e and don\u0026#x27;t need to. We could update middle components to accept \u003ccode\u003eperson\u003c/code\u003e parameters and pass them through to the child components that need it. We would also need to pass event handlers from the parent component through middle components down to child components. A doable process but messy and cumbersome. We will explore alternative solutions for handling this case in future articles.\u003c/p\u003e\u003cp\u003eEvent delegation is only one of many methods for sharing data across components. We will examine other methods in future articles.\u003c/p\u003e","scope":{}},"frontMatter":{"template":"post","title":"Blazor State Management Part II - Event Delegation","slug":"blazor-state-management-2-event-delegation","published":true,"date":"2019-03-14","description":"Data-binding is a useful concept and tool. In practice, data-binding lets Blazor developers manage and manipulate local component state and rest easy knowing the component UI is always working with, and reflecting the current state. The problem, data-binding does not work with state shared across components. In this article, we explore event delegation. A technique for handling state changes and for sharing state across components. ","category":"Blazor","tags":["Blazor"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"blazor-state-management-2-event-delegation"},"buildId":"it86kmHuw1morl_kI-W8Y","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-ca7eb3eb57fbc5dfe87d.js"></script><script src="/_next/static/chunks/main-15cc7adb6c68e37a6c83.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.386717e5d53cbb6c2786.js" async=""></script><script src="/_next/static/chunks/pages/_app-bc7fdccc4b180668915c.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-4a2fe920f2221d4f2899.js" async=""></script><script src="/_next/static/it86kmHuw1morl_kI-W8Y/_buildManifest.js" async=""></script><script src="/_next/static/it86kmHuw1morl_kI-W8Y/_ssgManifest.js" async=""></script></body></html>