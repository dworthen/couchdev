<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/750db2f755193dfeff7f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/750db2f755193dfeff7f.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-6fd6122508a3ecee2da5.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.386717e5d53cbb6c2786.js" as="script"/><link rel="preload" href="/_next/static/chunks/71247caf95475e3ea7f9a0f8a30beb258b23d005.6e2460ecc34e06341fc5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-38d928fb62d663b3f9dd.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bslug%5D-8c30f50305d85407af2b.js" as="script"/></head><body><div id="__next"><div class="sc-1ho0hv8-0 hslvLF"><div><main><div><h2>Problem</h2><p>You&#x27;ve written a TypeScript library. Now what? Time to publish, of course. But how? Do you publish it as a TypeScript module or compile it to JavaScript? Should it run in browser or Node.js? Or both? What about ES5 versus ES6 or ESNext? And don&#x27;t forget, some people prefer AMD modules.</p><p>In this article, I address all of these concerns and more. I will show you how to publish a TypeScript library to a broad audience. Publishing a TypeScript library can be complicated, but it doesn&#x27;t have to be.</p><h2>TLDR</h2><p>Use tsc to compile TypeScript source code to ES modules. Use webpack + babel to transpile ES modules to a umd package. Providing ES modules and a umd package supports a larger developer community.</p><hr/><h2>Solution</h2><p>A two-step build process.</p><ol><li>Compile TypeScript source code to ES modules using <code>tsc</code>, the TypeScript compiler.</li><li>Bundle ES modules into a single umd module using webpack and babel.</li></ol><hr/><h2>Why</h2><p>Providing both ES modules and a umd package gives developers options. Those working in modern ES2015+ environments can use the ES modules while the umd package supports those working in commonjs or web browser environments. Plus, modern build tools, such as Webpack and rollup, take advantage of ES modules. Build tools will parse, traverse and eliminate unused (dead) code of ES module dependencies.</p><hr/><h2>Why Webpack</h2><p>Unfortunately, the <a href="https://github.com/Microsoft/TypeScript/issues/8436">TypeScript compiler does not support global fallbacks when compiling to umd</a>. In short, umd packages produced by TypeScript do not support web browsers. Webpack, on the other hand, builds umd packages that support web browsers along with commonjs and amd environments.</p><hr/><h2>Why Babel</h2><p>To transpile ES2015 to the more widely supported ES5.</p><hr/><h2>Is Compilation Necessary</h2><p>What about writing TypeScript libraries for TypeScript developers? Is a build process necessary?</p><p>Yes. TypeScript does not compile dependencies (packages listed in node_modules). TypeScript libraries need to be compiled to JavaScript before publishing, even if the intended audience is TypeScript developers.</p><hr/><h2>Project Structure</h2><pre><code>Project/
|-- src/
    |-- sayHello.ts
    |-- index.ts
|-- tsconfig.json
|-- webpack.config.js
|-- package.json
</code></pre><h3>sayHello.ts</h3><p>A simple function to say hello! This is the only functionality of my awesome library.</p><pre><code class="language-js">export function sayHello(name: string): void {
  console.log(`Hello, ${name}`);
}
</code></pre><h3>index.ts</h3><p>This is the main entry point to the library and, as such, exposes the public API.</p><pre><code class="language-js">export { sayHello } from &quot;./sayHello&quot;;
</code></pre><h3>tsconfig.json</h3><p>The following options instruct the TypeScript compiler to output ES2015 modules.</p><pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    /* Basic Options */
    &quot;target&quot;: &quot;ES2015&quot; /* Build to ES2015 */,
    &quot;module&quot;: &quot;ES2015&quot; /* using ES2015 modules */,
    &quot;lib&quot;: [&quot;es2015&quot;, &quot;dom&quot;] /* Using ES2015 features and DOM APIs  */,
    &quot;declaration&quot;: true /* Generates corresponding&#x27;.d.ts&#x27; files. */,
    &quot;declarationDir&quot;: &quot;./dist/typings/&quot; /* build &#x27;.d.ts&#x27; files to ./dist/typeings */,
    &quot;outDir&quot;: &quot;./dist/esm/&quot; /* build to ./dist/esm/ */
  },
  &quot;files&quot;: [&quot;./src/index.ts&quot;],
  &quot;include&quot;: [&quot;./src/**/*.ts&quot;]
}
</code></pre><ul><li><strong>declarations</strong>: set to true, <code>tsc</code> outputs type definition files which, in turn, provides code intellisense support to TypeScript developers using the library.</li><li><strong>files</strong> specifies which files to compile. In this case, the main entry point to the library is listed. Compiling the main entry point, index.ts, compiles the rest of the library through dependencies.</li></ul><h3>webpack.config.js</h3><p>Webpack bundles ES modules outputted by <code>tsc</code> as a single umd package, targeting ES5. Developers can load the umd package within web browsers, via a script tag, or within commonjs or amd environments.</p><pre><code class="language-js">const path = require(&quot;path&quot;);

module.exports = (env, argv) =&gt; {
  return {
    entry: {
      index: path.resolve(__dirname, &quot;./dist/esm/index.js&quot;)
    },
    output: {
      path: path.resolve(__dirname, &quot;./dist/umd&quot;), // builds to ./dist/umd/
      filename: &quot;[name].js&quot;, // index.js
      library: &quot;myLibrary&quot;, // aka window.myLibrary
      libraryTarget: &quot;umd&quot;, // supports commonjs, amd and web browsers
      globalObject: &quot;this&quot;
    },
    module: {
      rules: [{ test: /\.t|js$/, use: &quot;babel-loader&quot; }]
    }
  };
};
</code></pre><ul><li><strong>entry</strong> specifies the entry point to the library. In this setup, webpack transpiles ES2015 to ES5 and does not compile TypeScript source code. For this reason, the file outputted by <code>tsc</code>, which is an ES2015 module, is specified as the input for webpack.</li><li><strong>library</strong> specifies the global variable name to use within web browsers.</li><li><strong>globalObject</strong> sets the global fallback object. The default is <code>window</code>, which is not defined in commonjs environments. Setting the global fallback object to <code>this</code> generates a umd package that supports both commonjs and web browser environments.</li><li><strong>module.rules</strong>: In this setup, webpack uses babel to transpile ES2015 code to the more widely supported ES5 syntax.</li></ul><h3>package.json</h3><p>Add the following to package.json</p><pre><code class="language-json">{
  &quot;main&quot;: &quot;./dist/umd/index.js&quot;,
  &quot;module&quot;: &quot;./dist/esm/index.js&quot;,
  &quot;types&quot;: &quot;./dist/typings/index.d.ts&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;build&quot;: &quot;webpack&quot;,
    &quot;prebuild&quot;: &quot;tsc&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;babel-core&quot;: &quot;^6.26.0&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.4&quot;,
    &quot;typescript&quot;: &quot;^2.7.2&quot;,
    &quot;webpack&quot;: &quot;^4.1.1&quot;,
    &quot;webpack-cli&quot;: &quot;^2.0.11&quot;
  }
}
</code></pre><ul><li><strong>main</strong> specifies the location of the umd package. Commonjs environments use this as the main entry point to the library.</li><li><strong>module</strong> specifies the location of the main ES2015 module. Consuming packages that use webpack or rollup will use this as the main entry point to the library and will eliminate unused (dead) code when bundling the library.</li><li><strong>types</strong> specifies the location of type definition files. Type definition files provide code intellisense and autocompletion support to TypeScript developers using the library.</li><li><strong>scripts.build</strong> runs <code>webpack</code>, transpiling ES2015 modules to an ES5 umd package.</li><li><strong>scripts.prebuild</strong> runs <code>tsc</code>, compiling TypeScript to ES2015 modules. This command automatically runs prior to <code>npm run build</code>.</li><li><strong>devDependencies</strong> lists the minimal set of packages needed to build both ES2015 modules and a umd package. Don&#x27;t forget to run <code>npm install</code>.</li></ul><hr/><h2>Build</h2><pre><code class="language-shell">$ npm run build
</code></pre><p>Outputs</p><p><img src="/media/npm-build.png" alt="npm-build"/></p><hr/><h2>Consume the built code</h2><h3>Web Browsers via script tags</h3><pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;
    &lt;script src=&quot;./path/to/dist/umd/index.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      // webpack exposes the library as a global, myLibrary
      myLibrary.sayHello(&quot;World&quot;);
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3>commonjs (Node)</h3><pre><code class="language-js">var myLibrary = require(&quot;myLibrary&quot;);

myLibrary.sayHello(&quot;World&quot;);
</code></pre><h3>ES modules</h3><pre><code class="language-js">import { sayHello } from &quot;myLibrary/esm/sayHello&quot;;

sayHello(&quot;World&quot;);
</code></pre><p>Developers using webpack do not have to specify ES module paths. Webpack will automatically use the ES modules based on the module path specified in package.json.</p><p><strong>webpack</strong></p><pre><code class="language-js">import { sayHello } from &quot;myLibrary&quot;;

sayHello(&quot;World&quot;);
</code></pre></div></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i \u003c arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i \u003c sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i \u003c sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Problem\"), mdx(\"p\", null, \"You've written a TypeScript library. Now what? Time to publish, of course. But how? Do you publish it as a TypeScript module or compile it to JavaScript? Should it run in browser or Node.js? Or both? What about ES5 versus ES6 or ESNext? And don't forget, some people prefer AMD modules.\"), mdx(\"p\", null, \"In this article, I address all of these concerns and more. I will show you how to publish a TypeScript library to a broad audience. Publishing a TypeScript library can be complicated, but it doesn't have to be.\"), mdx(\"h2\", null, \"TLDR\"), mdx(\"p\", null, \"Use tsc to compile TypeScript source code to ES modules. Use webpack + babel to transpile ES modules to a umd package. Providing ES modules and a umd package supports a larger developer community.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Solution\"), mdx(\"p\", null, \"A two-step build process.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Compile TypeScript source code to ES modules using \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tsc\"), \", the TypeScript compiler.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Bundle ES modules into a single umd module using webpack and babel.\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Why\"), mdx(\"p\", null, \"Providing both ES modules and a umd package gives developers options. Those working in modern ES2015+ environments can use the ES modules while the umd package supports those working in commonjs or web browser environments. Plus, modern build tools, such as Webpack and rollup, take advantage of ES modules. Build tools will parse, traverse and eliminate unused (dead) code of ES module dependencies.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Why Webpack\"), mdx(\"p\", null, \"Unfortunately, the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Microsoft/TypeScript/issues/8436\"\n  }, \"TypeScript compiler does not support global fallbacks when compiling to umd\"), \". In short, umd packages produced by TypeScript do not support web browsers. Webpack, on the other hand, builds umd packages that support web browsers along with commonjs and amd environments.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Why Babel\"), mdx(\"p\", null, \"To transpile ES2015 to the more widely supported ES5.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Is Compilation Necessary\"), mdx(\"p\", null, \"What about writing TypeScript libraries for TypeScript developers? Is a build process necessary?\"), mdx(\"p\", null, \"Yes. TypeScript does not compile dependencies (packages listed in node_modules). TypeScript libraries need to be compiled to JavaScript before publishing, even if the intended audience is TypeScript developers.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Project Structure\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Project/\\n|-- src/\\n    |-- sayHello.ts\\n    |-- index.ts\\n|-- tsconfig.json\\n|-- webpack.config.js\\n|-- package.json\\n\")), mdx(\"h3\", null, \"sayHello.ts\"), mdx(\"p\", null, \"A simple function to say hello! This is the only functionality of my awesome library.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function sayHello(name: string): void {\\n  console.log(`Hello, ${name}`);\\n}\\n\")), mdx(\"h3\", null, \"index.ts\"), mdx(\"p\", null, \"This is the main entry point to the library and, as such, exposes the public API.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export { sayHello } from \\\"./sayHello\\\";\\n\")), mdx(\"h3\", null, \"tsconfig.json\"), mdx(\"p\", null, \"The following options instruct the TypeScript compiler to output ES2015 modules.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n  \\\"compilerOptions\\\": {\\n    /* Basic Options */\\n    \\\"target\\\": \\\"ES2015\\\" /* Build to ES2015 */,\\n    \\\"module\\\": \\\"ES2015\\\" /* using ES2015 modules */,\\n    \\\"lib\\\": [\\\"es2015\\\", \\\"dom\\\"] /* Using ES2015 features and DOM APIs  */,\\n    \\\"declaration\\\": true /* Generates corresponding'.d.ts' files. */,\\n    \\\"declarationDir\\\": \\\"./dist/typings/\\\" /* build '.d.ts' files to ./dist/typeings */,\\n    \\\"outDir\\\": \\\"./dist/esm/\\\" /* build to ./dist/esm/ */\\n  },\\n  \\\"files\\\": [\\\"./src/index.ts\\\"],\\n  \\\"include\\\": [\\\"./src/**/*.ts\\\"]\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"declarations\"), \": set to true, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tsc\"), \" outputs type definition files which, in turn, provides code intellisense support to TypeScript developers using the library.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"files\"), \" specifies which files to compile. In this case, the main entry point to the library is listed. Compiling the main entry point, index.ts, compiles the rest of the library through dependencies.\")), mdx(\"h3\", null, \"webpack.config.js\"), mdx(\"p\", null, \"Webpack bundles ES modules outputted by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tsc\"), \" as a single umd package, targeting ES5. Developers can load the umd package within web browsers, via a script tag, or within commonjs or amd environments.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const path = require(\\\"path\\\");\\n\\nmodule.exports = (env, argv) =\u003e {\\n  return {\\n    entry: {\\n      index: path.resolve(__dirname, \\\"./dist/esm/index.js\\\")\\n    },\\n    output: {\\n      path: path.resolve(__dirname, \\\"./dist/umd\\\"), // builds to ./dist/umd/\\n      filename: \\\"[name].js\\\", // index.js\\n      library: \\\"myLibrary\\\", // aka window.myLibrary\\n      libraryTarget: \\\"umd\\\", // supports commonjs, amd and web browsers\\n      globalObject: \\\"this\\\"\\n    },\\n    module: {\\n      rules: [{ test: /\\\\.t|js$/, use: \\\"babel-loader\\\" }]\\n    }\\n  };\\n};\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"entry\"), \" specifies the entry point to the library. In this setup, webpack transpiles ES2015 to ES5 and does not compile TypeScript source code. For this reason, the file outputted by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tsc\"), \", which is an ES2015 module, is specified as the input for webpack.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"library\"), \" specifies the global variable name to use within web browsers.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"globalObject\"), \" sets the global fallback object. The default is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"window\"), \", which is not defined in commonjs environments. Setting the global fallback object to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"this\"), \" generates a umd package that supports both commonjs and web browser environments.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"module.rules\"), \": In this setup, webpack uses babel to transpile ES2015 code to the more widely supported ES5 syntax.\")), mdx(\"h3\", null, \"package.json\"), mdx(\"p\", null, \"Add the following to package.json\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n  \\\"main\\\": \\\"./dist/umd/index.js\\\",\\n  \\\"module\\\": \\\"./dist/esm/index.js\\\",\\n  \\\"types\\\": \\\"./dist/typings/index.d.ts\\\",\\n  \\\"scripts\\\": {\\n    \\\"test\\\": \\\"echo \\\\\\\"Error: no test specified\\\\\\\" \u0026\u0026 exit 1\\\",\\n    \\\"build\\\": \\\"webpack\\\",\\n    \\\"prebuild\\\": \\\"tsc\\\"\\n  },\\n  \\\"devDependencies\\\": {\\n    \\\"babel-core\\\": \\\"^6.26.0\\\",\\n    \\\"babel-loader\\\": \\\"^7.1.4\\\",\\n    \\\"typescript\\\": \\\"^2.7.2\\\",\\n    \\\"webpack\\\": \\\"^4.1.1\\\",\\n    \\\"webpack-cli\\\": \\\"^2.0.11\\\"\\n  }\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"main\"), \" specifies the location of the umd package. Commonjs environments use this as the main entry point to the library.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"module\"), \" specifies the location of the main ES2015 module. Consuming packages that use webpack or rollup will use this as the main entry point to the library and will eliminate unused (dead) code when bundling the library.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"types\"), \" specifies the location of type definition files. Type definition files provide code intellisense and autocompletion support to TypeScript developers using the library.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"scripts.build\"), \" runs \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"webpack\"), \", transpiling ES2015 modules to an ES5 umd package.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"scripts.prebuild\"), \" runs \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tsc\"), \", compiling TypeScript to ES2015 modules. This command automatically runs prior to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"npm run build\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"devDependencies\"), \" lists the minimal set of packages needed to build both ES2015 modules and a umd package. Don't forget to run \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"npm install\"), \".\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Build\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-shell\"\n  }, \"$ npm run build\\n\")), mdx(\"p\", null, \"Outputs\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/npm-build.png\",\n    \"alt\": \"npm-build\"\n  })), mdx(\"hr\", null), mdx(\"h2\", null, \"Consume the built code\"), mdx(\"h3\", null, \"Web Browsers via script tags\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-html\"\n  }, \"\u003c!DOCTYPE html\u003e\\n\u003chtml lang=\\\"en\\\"\u003e\\n  \u003chead\u003e\\n    \u003cmeta charset=\\\"UTF-8\\\" /\u003e\\n    \u003cmeta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /\u003e\\n    \u003cmeta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"ie=edge\\\" /\u003e\\n    \u003cscript src=\\\"./path/to/dist/umd/index.js\\\"\u003e\u003c/script\u003e\\n    \u003cscript\u003e\\n      // webpack exposes the library as a global, myLibrary\\n      myLibrary.sayHello(\\\"World\\\");\\n    \u003c/script\u003e\\n  \u003c/head\u003e\\n  \u003cbody\u003e\u003c/body\u003e\\n\u003c/html\u003e\\n\")), mdx(\"h3\", null, \"commonjs (Node)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var myLibrary = require(\\\"myLibrary\\\");\\n\\nmyLibrary.sayHello(\\\"World\\\");\\n\")), mdx(\"h3\", null, \"ES modules\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"import { sayHello } from \\\"myLibrary/esm/sayHello\\\";\\n\\nsayHello(\\\"World\\\");\\n\")), mdx(\"p\", null, \"Developers using webpack do not have to specify ES module paths. Webpack will automatically use the ES modules based on the module path specified in package.json.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"webpack\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"import { sayHello } from \\\"myLibrary\\\";\\n\\nsayHello(\\\"World\\\");\\n\")));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"\u003ch2\u003eProblem\u003c/h2\u003e\u003cp\u003eYou\u0026#x27;ve written a TypeScript library. Now what? Time to publish, of course. But how? Do you publish it as a TypeScript module or compile it to JavaScript? Should it run in browser or Node.js? Or both? What about ES5 versus ES6 or ESNext? And don\u0026#x27;t forget, some people prefer AMD modules.\u003c/p\u003e\u003cp\u003eIn this article, I address all of these concerns and more. I will show you how to publish a TypeScript library to a broad audience. Publishing a TypeScript library can be complicated, but it doesn\u0026#x27;t have to be.\u003c/p\u003e\u003ch2\u003eTLDR\u003c/h2\u003e\u003cp\u003eUse tsc to compile TypeScript source code to ES modules. Use webpack + babel to transpile ES modules to a umd package. Providing ES modules and a umd package supports a larger developer community.\u003c/p\u003e\u003chr/\u003e\u003ch2\u003eSolution\u003c/h2\u003e\u003cp\u003eA two-step build process.\u003c/p\u003e\u003col\u003e\u003cli\u003eCompile TypeScript source code to ES modules using \u003ccode\u003etsc\u003c/code\u003e, the TypeScript compiler.\u003c/li\u003e\u003cli\u003eBundle ES modules into a single umd module using webpack and babel.\u003c/li\u003e\u003c/ol\u003e\u003chr/\u003e\u003ch2\u003eWhy\u003c/h2\u003e\u003cp\u003eProviding both ES modules and a umd package gives developers options. Those working in modern ES2015+ environments can use the ES modules while the umd package supports those working in commonjs or web browser environments. Plus, modern build tools, such as Webpack and rollup, take advantage of ES modules. Build tools will parse, traverse and eliminate unused (dead) code of ES module dependencies.\u003c/p\u003e\u003chr/\u003e\u003ch2\u003eWhy Webpack\u003c/h2\u003e\u003cp\u003eUnfortunately, the \u003ca href=\"https://github.com/Microsoft/TypeScript/issues/8436\"\u003eTypeScript compiler does not support global fallbacks when compiling to umd\u003c/a\u003e. In short, umd packages produced by TypeScript do not support web browsers. Webpack, on the other hand, builds umd packages that support web browsers along with commonjs and amd environments.\u003c/p\u003e\u003chr/\u003e\u003ch2\u003eWhy Babel\u003c/h2\u003e\u003cp\u003eTo transpile ES2015 to the more widely supported ES5.\u003c/p\u003e\u003chr/\u003e\u003ch2\u003eIs Compilation Necessary\u003c/h2\u003e\u003cp\u003eWhat about writing TypeScript libraries for TypeScript developers? Is a build process necessary?\u003c/p\u003e\u003cp\u003eYes. TypeScript does not compile dependencies (packages listed in node_modules). TypeScript libraries need to be compiled to JavaScript before publishing, even if the intended audience is TypeScript developers.\u003c/p\u003e\u003chr/\u003e\u003ch2\u003eProject Structure\u003c/h2\u003e\u003cpre\u003e\u003ccode\u003eProject/\n|-- src/\n    |-- sayHello.ts\n    |-- index.ts\n|-- tsconfig.json\n|-- webpack.config.js\n|-- package.json\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003esayHello.ts\u003c/h3\u003e\u003cp\u003eA simple function to say hello! This is the only functionality of my awesome library.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003eexport function sayHello(name: string): void {\n  console.log(`Hello, ${name}`);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eindex.ts\u003c/h3\u003e\u003cp\u003eThis is the main entry point to the library and, as such, exposes the public API.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003eexport { sayHello } from \u0026quot;./sayHello\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003etsconfig.json\u003c/h3\u003e\u003cp\u003eThe following options instruct the TypeScript compiler to output ES2015 modules.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \u0026quot;compilerOptions\u0026quot;: {\n    /* Basic Options */\n    \u0026quot;target\u0026quot;: \u0026quot;ES2015\u0026quot; /* Build to ES2015 */,\n    \u0026quot;module\u0026quot;: \u0026quot;ES2015\u0026quot; /* using ES2015 modules */,\n    \u0026quot;lib\u0026quot;: [\u0026quot;es2015\u0026quot;, \u0026quot;dom\u0026quot;] /* Using ES2015 features and DOM APIs  */,\n    \u0026quot;declaration\u0026quot;: true /* Generates corresponding\u0026#x27;.d.ts\u0026#x27; files. */,\n    \u0026quot;declarationDir\u0026quot;: \u0026quot;./dist/typings/\u0026quot; /* build \u0026#x27;.d.ts\u0026#x27; files to ./dist/typeings */,\n    \u0026quot;outDir\u0026quot;: \u0026quot;./dist/esm/\u0026quot; /* build to ./dist/esm/ */\n  },\n  \u0026quot;files\u0026quot;: [\u0026quot;./src/index.ts\u0026quot;],\n  \u0026quot;include\u0026quot;: [\u0026quot;./src/**/*.ts\u0026quot;]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003edeclarations\u003c/strong\u003e: set to true, \u003ccode\u003etsc\u003c/code\u003e outputs type definition files which, in turn, provides code intellisense support to TypeScript developers using the library.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003efiles\u003c/strong\u003e specifies which files to compile. In this case, the main entry point to the library is listed. Compiling the main entry point, index.ts, compiles the rest of the library through dependencies.\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003ewebpack.config.js\u003c/h3\u003e\u003cp\u003eWebpack bundles ES modules outputted by \u003ccode\u003etsc\u003c/code\u003e as a single umd package, targeting ES5. Developers can load the umd package within web browsers, via a script tag, or within commonjs or amd environments.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst path = require(\u0026quot;path\u0026quot;);\n\nmodule.exports = (env, argv) =\u0026gt; {\n  return {\n    entry: {\n      index: path.resolve(__dirname, \u0026quot;./dist/esm/index.js\u0026quot;)\n    },\n    output: {\n      path: path.resolve(__dirname, \u0026quot;./dist/umd\u0026quot;), // builds to ./dist/umd/\n      filename: \u0026quot;[name].js\u0026quot;, // index.js\n      library: \u0026quot;myLibrary\u0026quot;, // aka window.myLibrary\n      libraryTarget: \u0026quot;umd\u0026quot;, // supports commonjs, amd and web browsers\n      globalObject: \u0026quot;this\u0026quot;\n    },\n    module: {\n      rules: [{ test: /\\.t|js$/, use: \u0026quot;babel-loader\u0026quot; }]\n    }\n  };\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eentry\u003c/strong\u003e specifies the entry point to the library. In this setup, webpack transpiles ES2015 to ES5 and does not compile TypeScript source code. For this reason, the file outputted by \u003ccode\u003etsc\u003c/code\u003e, which is an ES2015 module, is specified as the input for webpack.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003elibrary\u003c/strong\u003e specifies the global variable name to use within web browsers.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eglobalObject\u003c/strong\u003e sets the global fallback object. The default is \u003ccode\u003ewindow\u003c/code\u003e, which is not defined in commonjs environments. Setting the global fallback object to \u003ccode\u003ethis\u003c/code\u003e generates a umd package that supports both commonjs and web browser environments.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003emodule.rules\u003c/strong\u003e: In this setup, webpack uses babel to transpile ES2015 code to the more widely supported ES5 syntax.\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003epackage.json\u003c/h3\u003e\u003cp\u003eAdd the following to package.json\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \u0026quot;main\u0026quot;: \u0026quot;./dist/umd/index.js\u0026quot;,\n  \u0026quot;module\u0026quot;: \u0026quot;./dist/esm/index.js\u0026quot;,\n  \u0026quot;types\u0026quot;: \u0026quot;./dist/typings/index.d.ts\u0026quot;,\n  \u0026quot;scripts\u0026quot;: {\n    \u0026quot;test\u0026quot;: \u0026quot;echo \\\u0026quot;Error: no test specified\\\u0026quot; \u0026amp;\u0026amp; exit 1\u0026quot;,\n    \u0026quot;build\u0026quot;: \u0026quot;webpack\u0026quot;,\n    \u0026quot;prebuild\u0026quot;: \u0026quot;tsc\u0026quot;\n  },\n  \u0026quot;devDependencies\u0026quot;: {\n    \u0026quot;babel-core\u0026quot;: \u0026quot;^6.26.0\u0026quot;,\n    \u0026quot;babel-loader\u0026quot;: \u0026quot;^7.1.4\u0026quot;,\n    \u0026quot;typescript\u0026quot;: \u0026quot;^2.7.2\u0026quot;,\n    \u0026quot;webpack\u0026quot;: \u0026quot;^4.1.1\u0026quot;,\n    \u0026quot;webpack-cli\u0026quot;: \u0026quot;^2.0.11\u0026quot;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003emain\u003c/strong\u003e specifies the location of the umd package. Commonjs environments use this as the main entry point to the library.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003emodule\u003c/strong\u003e specifies the location of the main ES2015 module. Consuming packages that use webpack or rollup will use this as the main entry point to the library and will eliminate unused (dead) code when bundling the library.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003etypes\u003c/strong\u003e specifies the location of type definition files. Type definition files provide code intellisense and autocompletion support to TypeScript developers using the library.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003escripts.build\u003c/strong\u003e runs \u003ccode\u003ewebpack\u003c/code\u003e, transpiling ES2015 modules to an ES5 umd package.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003escripts.prebuild\u003c/strong\u003e runs \u003ccode\u003etsc\u003c/code\u003e, compiling TypeScript to ES2015 modules. This command automatically runs prior to \u003ccode\u003enpm run build\u003c/code\u003e.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003edevDependencies\u003c/strong\u003e lists the minimal set of packages needed to build both ES2015 modules and a umd package. Don\u0026#x27;t forget to run \u003ccode\u003enpm install\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003chr/\u003e\u003ch2\u003eBuild\u003c/h2\u003e\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ npm run build\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOutputs\u003c/p\u003e\u003cp\u003e\u003cimg src=\"/media/npm-build.png\" alt=\"npm-build\"/\u003e\u003c/p\u003e\u003chr/\u003e\u003ch2\u003eConsume the built code\u003c/h2\u003e\u003ch3\u003eWeb Browsers via script tags\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;!DOCTYPE html\u0026gt;\n\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\n  \u0026lt;head\u0026gt;\n    \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot; /\u0026gt;\n    \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot; /\u0026gt;\n    \u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;ie=edge\u0026quot; /\u0026gt;\n    \u0026lt;script src=\u0026quot;./path/to/dist/umd/index.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\n    \u0026lt;script\u0026gt;\n      // webpack exposes the library as a global, myLibrary\n      myLibrary.sayHello(\u0026quot;World\u0026quot;);\n    \u0026lt;/script\u0026gt;\n  \u0026lt;/head\u0026gt;\n  \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt;\n\u0026lt;/html\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003ecommonjs (Node)\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003evar myLibrary = require(\u0026quot;myLibrary\u0026quot;);\n\nmyLibrary.sayHello(\u0026quot;World\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eES modules\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003eimport { sayHello } from \u0026quot;myLibrary/esm/sayHello\u0026quot;;\n\nsayHello(\u0026quot;World\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDevelopers using webpack do not have to specify ES module paths. Webpack will automatically use the ES modules based on the module path specified in package.json.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ewebpack\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003eimport { sayHello } from \u0026quot;myLibrary\u0026quot;;\n\nsayHello(\u0026quot;World\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e","scope":{}},"frontMatter":{"title":"Authoring TypeScript Libraries","date":"2018-03-16","template":"post","published":true,"slug":"authoring-typescript-libraries","category":"TypeScript","tags":["TypeScript"],"description":"You've written a TypeScript library. Now what? Time to publish, of course. But how? Do you publish it as a TypeScript module or compile it to JavaScript? Should it run in browser or Node.js, or both? What about ES5  versus ES6 or ESNext? And don't forget, some people prefer AMD modules."}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"authoring-typescript-libraries"},"buildId":"c-PzTcYntvLLEE3J2MI77","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-4a659121523c89b6d810.js"></script><script src="/_next/static/chunks/main-6fd6122508a3ecee2da5.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.386717e5d53cbb6c2786.js" async=""></script><script src="/_next/static/chunks/71247caf95475e3ea7f9a0f8a30beb258b23d005.6e2460ecc34e06341fc5.js" async=""></script><script src="/_next/static/chunks/pages/_app-38d928fb62d663b3f9dd.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-8c30f50305d85407af2b.js" async=""></script><script src="/_next/static/c-PzTcYntvLLEE3J2MI77/_buildManifest.js" async=""></script><script src="/_next/static/c-PzTcYntvLLEE3J2MI77/_ssgManifest.js" async=""></script></body></html>