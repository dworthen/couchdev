<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/4c0306d5b03180f9727b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4c0306d5b03180f9727b.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-15cc7adb6c68e37a6c83.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.386717e5d53cbb6c2786.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-bc7fdccc4b180668915c.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bslug%5D-4a2fe920f2221d4f2899.js" as="script"/></head><body><div id="__next"><div class="Layout__StyledMain-sc-1ho0hv8-0 fsweVq"><header class="Header__StyledHeader-wxqfda-0 bIiJxr"><div><h2><a href="/">Couch Dev</a> <small>Prerecorded from my couch, it&#x27;s a dev making sense of dev things!</small></h2></div></header><div><main><div><blockquote><p><strong>This article explores data-binding in Blazor 0.7.0</strong></p><p><strong>The source code for this article can be found <a href="https://github.com/dworthen/BlazorStateManagement/tree/part-01-data-binding">here</a>.</strong></p></blockquote><p><strong>This article is part of a Blazor state management exploration series.</strong></p><ol><li>Blazor State Management Part I - Data-Binding</li><li><a href="/posts/blazor-state-management-2-event-delegation">Blazor State Management Part II - Event Delegation</a></li><li><a href="/posts/blazor-state-management-3-cascading-parameters">Blazor State Management Part III - Cascading Parameters</a></li></ol><hr/><p>MVVM (Model-View-ViewModel) is a UI design pattern that separates the data layer, model, from the presentation layer, view. The pattern bridges the two layers with the ViewModel which is responsible for converting the model into a view-friendly form and for relaying view-driven updates back to the model.</p><p><img src="/media/mvvm-concrete.png" alt="MVVM Diagram"/></p><p>An important part of the MVVM pattern is the communication between the view and ViewModel. When the ViewModel updates data the view automatically updates to reflect the changes. The opposite is also true. When the view updates data through user interactions, the ViewModel references the most up-to-date data. This is known as data-binding.</p><p>In short, data-binding means that the view always reflects the current ViewModel and the ViewModel stays in sync with updates that occur in the view, user-driven or otherwise.</p><p>Here is an example of data-binding from the Blazor documentation.</p><pre><code class="language-aspnet">&lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;italicsCheck&quot; bind=&quot;@_italicsCheck&quot; /&gt;
Current Value: @_italicsCheck

@functions {
    private bool _italicsCheck { get; set; } = false;
}
</code></pre><p>The above is a simple component. The properties defined in the functions section act as our ViewModel and are accessible to the above HTML, the view, through razor syntax. In this case, the view displays a checked checkbox when the ViewModel&#x27;s <code>_italicsCheck</code> is true. Furthermore, the value stored in <code>_italicsCheck</code> updates as users toggle the checkbox in the UI to match the new toggled state. This functionality, data-binding, is achieved with the <code>bind</code> attribute.</p><p>Two-way data-binding out of the box! So Blazor supports the MVVM design pattern, right? Not quite. Let&#x27;s examine what happens when data is used across components.</p><pre><code class="language-aspnet">@* UpdateMessage.cshtml *@
&lt;div&gt;UpdateMessage Component Current Value: @Message&lt;/div&gt;

&lt;div&gt;
    &lt;input type=&quot;text&quot; bind=&quot;@Message&quot; /&gt;
&lt;/div&gt;

@functions {
    [Parameter] string Message { get; set; }
}
</code></pre><pre><code class="language-aspnet">@* DisplayMessage.cshtml *@
&lt;div&gt;Display Message Component Current Value: @Message&lt;/div&gt;

@functions {
    [Parameter] string Message { get; set; }
}
</code></pre><p>And update <code>index.cshtml</code></p><pre><code class="language-aspnet">@* index.cshtml *@
@page &quot;/&quot;

&lt;DisplayMessage Message=&quot;@Message&quot;&gt;&lt;/DisplayMessage&gt;
&lt;UpdateMessage Message=&quot;@Message&quot;&gt;&lt;/UpdateMessage&gt;

@functions {
    private string Message { get; set; } = &quot;Hello World&quot;;
}
</code></pre><p>Now, two components are using the same data. Let&#x27;s see what happens when we update the message in UpdateMessage. Do updates propagate to the DisplayMessage component?</p><p><img src="/media/data-bind-1.png" alt="data-binding a string"/></p><p>Unfortunately, no. Data-binding is limited to the current component and child components. But wait! Like two-way binding on input tags, Blazor supports two-way binding on custom component parameters using the <code>bind-</code> prefix attribute. Let&#x27;s implement that now.</p><pre><code class="language-aspnet">@* index.cshtml *@
...
&lt;DisplayMessage bind-Message=&quot;@Message&quot;&gt;&lt;/DisplayMessage&gt;
&lt;UpdateMessage bind-Message=&quot;@Message&quot;&gt;&lt;/UpdateMessage&gt;
...
</code></pre><p>The <code>bind-</code> prefix allows one to bind data to custom-component parameters. Before refreshing the application, we need to add the following <code>Action</code> parameter to UpdateMessage and DisplayMessage.</p><pre><code class="language-aspnet">@* DisplayMessage.cshtml and UpdateMessage.cshtml *@
...
@functions {
    ...
    [Parameter] Action&lt;string&gt; MessageChanged { get; set; }
}
</code></pre><p>We will examine how this works in a future article. For now, cross your fingers!</p><p><img src="/media/data-bind-2.png" alt="data-binding with bind attribute"/></p><p>No luck! Surely, the issue is that we are sharing a string across components. Passing a string is to pass by value. So each component is receiving its own copy of the string. AHA! Let&#x27;s try using a POCO as our state object.</p><pre><code class="language-aspnet">@* Person.cs *@
public class Person
{
    public string Name { get; set; }
}
</code></pre><p>And repeat the same pattern from before...</p><pre><code class="language-aspnet">@* DisplayPerson *@
&lt;div&gt;DisplayPerson Component - Person&#x27;s Name: @person.Name&lt;/div&gt;

@functions {
    [Parameter] Person person { get; set; }
}
</code></pre><pre><code class="language-aspnet">@* UpdatePerson Component *@
&lt;div&gt;UpdatePerson Component - Person&#x27;s Name: @person.Name&lt;/div&gt;

&lt;div&gt;
    &lt;input type=&quot;text&quot; bind=&quot;@person.Name&quot; /&gt;
&lt;/div&gt;

@functions {
    [Parameter] Person person { get; set; }
}
</code></pre><p>Let&#x27;s not forget to update <code>index.cshtml</code> to use the new Person components.</p><pre><code class="language-aspnet">@* index.cshtml *@
...
&lt;DisplayPerson person=&quot;@person&quot;&gt;&lt;/DisplayPerson&gt;
&lt;UpdatePerson person=&quot;@person&quot;&gt;&lt;/UpdatePerson&gt;

@functions {
    ...
    private Person person { get; set; } = new Person { Name = &quot;Derek&quot; };
}
</code></pre><p>Refreshing our browser we get</p><p><img src="/media/data-binding-with-poco.png" alt="Data-binding with poco"/></p><p>Don&#x27;t panic! Hope is not lost. Instead of relying on Blazor&#x27;s data-binding let&#x27;s try responding to the <code>onchange</code> event manually.</p><pre><code class="language-aspnet">@* UpdatePerson.cshtml *@
...
    &lt;input type=&quot;text&quot; value=&quot;@person.Name&quot; onchange=&quot;@OnChange&quot; /&gt;
...
@functions {
    ...
    private void OnChange(UIChangeEventArgs e)
    {
        person.Name = (string)e.Value;
    }
}
</code></pre><p>If you refresh the browser, you will see that we still have the same functionality. Well, we didn&#x27;t break anything. We still have component-scoped data-binding. Why use an event listener instead of bind? Using an event listener allows us to have side effects, such as calling <code>StateHasChanged</code>.</p><pre><code class="language-aspnet">@* UpdatePerson.cshtml *@
private void OnChange(UIChangeEventArgs e)
{
    person.Name = (string)e.Value;
    StateHasChanged();
}
</code></pre><p><code>StateHasChanged</code>, if you haven&#x27;t guessed, is a Blazor function that tells the system that the state has changed which, in turn, triggers a rerender. Blazor renders UI similar to many popular JS frameworks. It maintains a virtual dom. When a rerender occurs, Blazor generates a new virtual dom, diffs it with the previous virtual dom and then minimally updates the real dom.</p><p>Maybe, just maybe, manually calling <code>StateHasChanged</code> causes Blazor to rerender and diff the entire virtual dom and not just the local component dom. And...</p><p><img src="/media/data-binding-with-satehaschanged.png" alt="Data-binding with statehaschanged"/></p><p>Turns out, <code>StateHasChanged</code> is scoped to the current component and child components. No different from bind.</p><p>What gives? DisplayPerson and UpdatePerson receive the same Person object. It is an object! It has to be passed by reference, right? This is true. DisplayPerson and UpdatePerson receive a reference to the same object. The problem lies in how rerendering works in Blazor.</p><p>Let&#x27;s prove that the shortcoming lies within the rendering mechanism. Add the following code to DisplayPerson</p><pre><code class="language-aspnet">...
@functions {
...
    protected async override Task OnInitAsync()
        {
            await base.OnInitAsync();
            System.Timers.Timer timer = new System.Timers.Timer(10000);
            await Task.Delay(6000);
            StateHasChanged();
        }
...
}
</code></pre><p>After 6 seconds, DisplayPerson calls <code>StatehasChanged</code>, triggering a rerender. This should give us enough time to load the page, update the state within the UpdatePerson component and wait and see if DisplayPerson will display the updated name after StateHasChanged has been called. Go quick. You have 6 seconds. If all goes well, DisplayPerson, after 6 seconds, should display the updated name since it is referencing the same object.</p><p><img src="/media/data-binding-with-a-delay.gif" alt="Data-binding with a delay"/></p><p>Notice that the name is updating to match user input</p><hr/><h2>Conclusion</h2><p>In summary, Blazor supports component-based data-binding, a process for keeping the ViewModel and view in sync. Data-binding is component based and will not work across components. In future articles, I will examine methods for sharing data across components and ensuring components use and reflect the most up-to-date data.</p></div></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i \u003c arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i \u003c sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i \u003c sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"This article explores data-binding in Blazor 0.7.0\")), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"The source code for this article can be found \", mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://github.com/dworthen/BlazorStateManagement/tree/part-01-data-binding\"\n  }, \"here\"), \".\"))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"This article is part of a Blazor state management exploration series.\")), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Blazor State Management Part I - Data-Binding\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/posts/blazor-state-management-2-event-delegation\"\n  }, \"Blazor State Management Part II - Event Delegation\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/posts/blazor-state-management-3-cascading-parameters\"\n  }, \"Blazor State Management Part III - Cascading Parameters\"))), mdx(\"hr\", null), mdx(\"p\", null, \"MVVM (Model-View-ViewModel) is a UI design pattern that separates the data layer, model, from the presentation layer, view. The pattern bridges the two layers with the ViewModel which is responsible for converting the model into a view-friendly form and for relaying view-driven updates back to the model.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/mvvm-concrete.png\",\n    \"alt\": \"MVVM Diagram\"\n  })), mdx(\"p\", null, \"An important part of the MVVM pattern is the communication between the view and ViewModel. When the ViewModel updates data the view automatically updates to reflect the changes. The opposite is also true. When the view updates data through user interactions, the ViewModel references the most up-to-date data. This is known as data-binding.\"), mdx(\"p\", null, \"In short, data-binding means that the view always reflects the current ViewModel and the ViewModel stays in sync with updates that occur in the view, user-driven or otherwise.\"), mdx(\"p\", null, \"Here is an example of data-binding from the Blazor documentation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"\u003cinput type=\\\"checkbox\\\" class=\\\"form-check-input\\\" id=\\\"italicsCheck\\\" bind=\\\"@_italicsCheck\\\" /\u003e\\nCurrent Value: @_italicsCheck\\n\\n@functions {\\n    private bool _italicsCheck { get; set; } = false;\\n}\\n\")), mdx(\"p\", null, \"The above is a simple component. The properties defined in the functions section act as our ViewModel and are accessible to the above HTML, the view, through razor syntax. In this case, the view displays a checked checkbox when the ViewModel's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_italicsCheck\"), \" is true. Furthermore, the value stored in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_italicsCheck\"), \" updates as users toggle the checkbox in the UI to match the new toggled state. This functionality, data-binding, is achieved with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bind\"), \" attribute.\"), mdx(\"p\", null, \"Two-way data-binding out of the box! So Blazor supports the MVVM design pattern, right? Not quite. Let's examine what happens when data is used across components.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* UpdateMessage.cshtml *@\\n\u003cdiv\u003eUpdateMessage Component Current Value: @Message\u003c/div\u003e\\n\\n\u003cdiv\u003e\\n    \u003cinput type=\\\"text\\\" bind=\\\"@Message\\\" /\u003e\\n\u003c/div\u003e\\n\\n@functions {\\n    [Parameter] string Message { get; set; }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* DisplayMessage.cshtml *@\\n\u003cdiv\u003eDisplay Message Component Current Value: @Message\u003c/div\u003e\\n\\n@functions {\\n    [Parameter] string Message { get; set; }\\n}\\n\")), mdx(\"p\", null, \"And update \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.cshtml\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* index.cshtml *@\\n@page \\\"/\\\"\\n\\n\u003cDisplayMessage Message=\\\"@Message\\\"\u003e\u003c/DisplayMessage\u003e\\n\u003cUpdateMessage Message=\\\"@Message\\\"\u003e\u003c/UpdateMessage\u003e\\n\\n@functions {\\n    private string Message { get; set; } = \\\"Hello World\\\";\\n}\\n\")), mdx(\"p\", null, \"Now, two components are using the same data. Let's see what happens when we update the message in UpdateMessage. Do updates propagate to the DisplayMessage component?\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/data-bind-1.png\",\n    \"alt\": \"data-binding a string\"\n  })), mdx(\"p\", null, \"Unfortunately, no. Data-binding is limited to the current component and child components. But wait! Like two-way binding on input tags, Blazor supports two-way binding on custom component parameters using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bind-\"), \" prefix attribute. Let's implement that now.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* index.cshtml *@\\n...\\n\u003cDisplayMessage bind-Message=\\\"@Message\\\"\u003e\u003c/DisplayMessage\u003e\\n\u003cUpdateMessage bind-Message=\\\"@Message\\\"\u003e\u003c/UpdateMessage\u003e\\n...\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bind-\"), \" prefix allows one to bind data to custom-component parameters. Before refreshing the application, we need to add the following \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Action\"), \" parameter to UpdateMessage and DisplayMessage.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* DisplayMessage.cshtml and UpdateMessage.cshtml *@\\n...\\n@functions {\\n    ...\\n    [Parameter] Action\u003cstring\u003e MessageChanged { get; set; }\\n}\\n\")), mdx(\"p\", null, \"We will examine how this works in a future article. For now, cross your fingers!\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/data-bind-2.png\",\n    \"alt\": \"data-binding with bind attribute\"\n  })), mdx(\"p\", null, \"No luck! Surely, the issue is that we are sharing a string across components. Passing a string is to pass by value. So each component is receiving its own copy of the string. AHA! Let's try using a POCO as our state object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* Person.cs *@\\npublic class Person\\n{\\n    public string Name { get; set; }\\n}\\n\")), mdx(\"p\", null, \"And repeat the same pattern from before...\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* DisplayPerson *@\\n\u003cdiv\u003eDisplayPerson Component - Person's Name: @person.Name\u003c/div\u003e\\n\\n@functions {\\n    [Parameter] Person person { get; set; }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* UpdatePerson Component *@\\n\u003cdiv\u003eUpdatePerson Component - Person's Name: @person.Name\u003c/div\u003e\\n\\n\u003cdiv\u003e\\n    \u003cinput type=\\\"text\\\" bind=\\\"@person.Name\\\" /\u003e\\n\u003c/div\u003e\\n\\n@functions {\\n    [Parameter] Person person { get; set; }\\n}\\n\")), mdx(\"p\", null, \"Let's not forget to update \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.cshtml\"), \" to use the new Person components.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* index.cshtml *@\\n...\\n\u003cDisplayPerson person=\\\"@person\\\"\u003e\u003c/DisplayPerson\u003e\\n\u003cUpdatePerson person=\\\"@person\\\"\u003e\u003c/UpdatePerson\u003e\\n\\n@functions {\\n    ...\\n    private Person person { get; set; } = new Person { Name = \\\"Derek\\\" };\\n}\\n\")), mdx(\"p\", null, \"Refreshing our browser we get\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/data-binding-with-poco.png\",\n    \"alt\": \"Data-binding with poco\"\n  })), mdx(\"p\", null, \"Don't panic! Hope is not lost. Instead of relying on Blazor's data-binding let's try responding to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onchange\"), \" event manually.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* UpdatePerson.cshtml *@\\n...\\n    \u003cinput type=\\\"text\\\" value=\\\"@person.Name\\\" onchange=\\\"@OnChange\\\" /\u003e\\n...\\n@functions {\\n    ...\\n    private void OnChange(UIChangeEventArgs e)\\n    {\\n        person.Name = (string)e.Value;\\n    }\\n}\\n\")), mdx(\"p\", null, \"If you refresh the browser, you will see that we still have the same functionality. Well, we didn't break anything. We still have component-scoped data-binding. Why use an event listener instead of bind? Using an event listener allows us to have side effects, such as calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StateHasChanged\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* UpdatePerson.cshtml *@\\nprivate void OnChange(UIChangeEventArgs e)\\n{\\n    person.Name = (string)e.Value;\\n    StateHasChanged();\\n}\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StateHasChanged\"), \", if you haven't guessed, is a Blazor function that tells the system that the state has changed which, in turn, triggers a rerender. Blazor renders UI similar to many popular JS frameworks. It maintains a virtual dom. When a rerender occurs, Blazor generates a new virtual dom, diffs it with the previous virtual dom and then minimally updates the real dom.\"), mdx(\"p\", null, \"Maybe, just maybe, manually calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StateHasChanged\"), \" causes Blazor to rerender and diff the entire virtual dom and not just the local component dom. And...\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/data-binding-with-satehaschanged.png\",\n    \"alt\": \"Data-binding with statehaschanged\"\n  })), mdx(\"p\", null, \"Turns out, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StateHasChanged\"), \" is scoped to the current component and child components. No different from bind.\"), mdx(\"p\", null, \"What gives? DisplayPerson and UpdatePerson receive the same Person object. It is an object! It has to be passed by reference, right? This is true. DisplayPerson and UpdatePerson receive a reference to the same object. The problem lies in how rerendering works in Blazor.\"), mdx(\"p\", null, \"Let's prove that the shortcoming lies within the rendering mechanism. Add the following code to DisplayPerson\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"...\\n@functions {\\n...\\n    protected async override Task OnInitAsync()\\n        {\\n            await base.OnInitAsync();\\n            System.Timers.Timer timer = new System.Timers.Timer(10000);\\n            await Task.Delay(6000);\\n            StateHasChanged();\\n        }\\n...\\n}\\n\")), mdx(\"p\", null, \"After 6 seconds, DisplayPerson calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StatehasChanged\"), \", triggering a rerender. This should give us enough time to load the page, update the state within the UpdatePerson component and wait and see if DisplayPerson will display the updated name after StateHasChanged has been called. Go quick. You have 6 seconds. If all goes well, DisplayPerson, after 6 seconds, should display the updated name since it is referencing the same object.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/data-binding-with-a-delay.gif\",\n    \"alt\": \"Data-binding with a delay\"\n  })), mdx(\"p\", null, \"Notice that the name is updating to match user input\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"In summary, Blazor supports component-based data-binding, a process for keeping the ViewModel and view in sync. Data-binding is component based and will not work across components. In future articles, I will examine methods for sharing data across components and ensuring components use and reflect the most up-to-date data.\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003eThis article explores data-binding in Blazor 0.7.0\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eThe source code for this article can be found \u003ca href=\"https://github.com/dworthen/BlazorStateManagement/tree/part-01-data-binding\"\u003ehere\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e\u003cstrong\u003eThis article is part of a Blazor state management exploration series.\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003eBlazor State Management Part I - Data-Binding\u003c/li\u003e\u003cli\u003e\u003ca href=\"/posts/blazor-state-management-2-event-delegation\"\u003eBlazor State Management Part II - Event Delegation\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"/posts/blazor-state-management-3-cascading-parameters\"\u003eBlazor State Management Part III - Cascading Parameters\u003c/a\u003e\u003c/li\u003e\u003c/ol\u003e\u003chr/\u003e\u003cp\u003eMVVM (Model-View-ViewModel) is a UI design pattern that separates the data layer, model, from the presentation layer, view. The pattern bridges the two layers with the ViewModel which is responsible for converting the model into a view-friendly form and for relaying view-driven updates back to the model.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"/media/mvvm-concrete.png\" alt=\"MVVM Diagram\"/\u003e\u003c/p\u003e\u003cp\u003eAn important part of the MVVM pattern is the communication between the view and ViewModel. When the ViewModel updates data the view automatically updates to reflect the changes. The opposite is also true. When the view updates data through user interactions, the ViewModel references the most up-to-date data. This is known as data-binding.\u003c/p\u003e\u003cp\u003eIn short, data-binding means that the view always reflects the current ViewModel and the ViewModel stays in sync with updates that occur in the view, user-driven or otherwise.\u003c/p\u003e\u003cp\u003eHere is an example of data-binding from the Blazor documentation.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e\u0026lt;input type=\u0026quot;checkbox\u0026quot; class=\u0026quot;form-check-input\u0026quot; id=\u0026quot;italicsCheck\u0026quot; bind=\u0026quot;@_italicsCheck\u0026quot; /\u0026gt;\nCurrent Value: @_italicsCheck\n\n@functions {\n    private bool _italicsCheck { get; set; } = false;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above is a simple component. The properties defined in the functions section act as our ViewModel and are accessible to the above HTML, the view, through razor syntax. In this case, the view displays a checked checkbox when the ViewModel\u0026#x27;s \u003ccode\u003e_italicsCheck\u003c/code\u003e is true. Furthermore, the value stored in \u003ccode\u003e_italicsCheck\u003c/code\u003e updates as users toggle the checkbox in the UI to match the new toggled state. This functionality, data-binding, is achieved with the \u003ccode\u003ebind\u003c/code\u003e attribute.\u003c/p\u003e\u003cp\u003eTwo-way data-binding out of the box! So Blazor supports the MVVM design pattern, right? Not quite. Let\u0026#x27;s examine what happens when data is used across components.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* UpdateMessage.cshtml *@\n\u0026lt;div\u0026gt;UpdateMessage Component Current Value: @Message\u0026lt;/div\u0026gt;\n\n\u0026lt;div\u0026gt;\n    \u0026lt;input type=\u0026quot;text\u0026quot; bind=\u0026quot;@Message\u0026quot; /\u0026gt;\n\u0026lt;/div\u0026gt;\n\n@functions {\n    [Parameter] string Message { get; set; }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* DisplayMessage.cshtml *@\n\u0026lt;div\u0026gt;Display Message Component Current Value: @Message\u0026lt;/div\u0026gt;\n\n@functions {\n    [Parameter] string Message { get; set; }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd update \u003ccode\u003eindex.cshtml\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* index.cshtml *@\n@page \u0026quot;/\u0026quot;\n\n\u0026lt;DisplayMessage Message=\u0026quot;@Message\u0026quot;\u0026gt;\u0026lt;/DisplayMessage\u0026gt;\n\u0026lt;UpdateMessage Message=\u0026quot;@Message\u0026quot;\u0026gt;\u0026lt;/UpdateMessage\u0026gt;\n\n@functions {\n    private string Message { get; set; } = \u0026quot;Hello World\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, two components are using the same data. Let\u0026#x27;s see what happens when we update the message in UpdateMessage. Do updates propagate to the DisplayMessage component?\u003c/p\u003e\u003cp\u003e\u003cimg src=\"/media/data-bind-1.png\" alt=\"data-binding a string\"/\u003e\u003c/p\u003e\u003cp\u003eUnfortunately, no. Data-binding is limited to the current component and child components. But wait! Like two-way binding on input tags, Blazor supports two-way binding on custom component parameters using the \u003ccode\u003ebind-\u003c/code\u003e prefix attribute. Let\u0026#x27;s implement that now.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* index.cshtml *@\n...\n\u0026lt;DisplayMessage bind-Message=\u0026quot;@Message\u0026quot;\u0026gt;\u0026lt;/DisplayMessage\u0026gt;\n\u0026lt;UpdateMessage bind-Message=\u0026quot;@Message\u0026quot;\u0026gt;\u0026lt;/UpdateMessage\u0026gt;\n...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003ebind-\u003c/code\u003e prefix allows one to bind data to custom-component parameters. Before refreshing the application, we need to add the following \u003ccode\u003eAction\u003c/code\u003e parameter to UpdateMessage and DisplayMessage.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* DisplayMessage.cshtml and UpdateMessage.cshtml *@\n...\n@functions {\n    ...\n    [Parameter] Action\u0026lt;string\u0026gt; MessageChanged { get; set; }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe will examine how this works in a future article. For now, cross your fingers!\u003c/p\u003e\u003cp\u003e\u003cimg src=\"/media/data-bind-2.png\" alt=\"data-binding with bind attribute\"/\u003e\u003c/p\u003e\u003cp\u003eNo luck! Surely, the issue is that we are sharing a string across components. Passing a string is to pass by value. So each component is receiving its own copy of the string. AHA! Let\u0026#x27;s try using a POCO as our state object.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* Person.cs *@\npublic class Person\n{\n    public string Name { get; set; }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd repeat the same pattern from before...\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* DisplayPerson *@\n\u0026lt;div\u0026gt;DisplayPerson Component - Person\u0026#x27;s Name: @person.Name\u0026lt;/div\u0026gt;\n\n@functions {\n    [Parameter] Person person { get; set; }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* UpdatePerson Component *@\n\u0026lt;div\u0026gt;UpdatePerson Component - Person\u0026#x27;s Name: @person.Name\u0026lt;/div\u0026gt;\n\n\u0026lt;div\u0026gt;\n    \u0026lt;input type=\u0026quot;text\u0026quot; bind=\u0026quot;@person.Name\u0026quot; /\u0026gt;\n\u0026lt;/div\u0026gt;\n\n@functions {\n    [Parameter] Person person { get; set; }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet\u0026#x27;s not forget to update \u003ccode\u003eindex.cshtml\u003c/code\u003e to use the new Person components.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* index.cshtml *@\n...\n\u0026lt;DisplayPerson person=\u0026quot;@person\u0026quot;\u0026gt;\u0026lt;/DisplayPerson\u0026gt;\n\u0026lt;UpdatePerson person=\u0026quot;@person\u0026quot;\u0026gt;\u0026lt;/UpdatePerson\u0026gt;\n\n@functions {\n    ...\n    private Person person { get; set; } = new Person { Name = \u0026quot;Derek\u0026quot; };\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRefreshing our browser we get\u003c/p\u003e\u003cp\u003e\u003cimg src=\"/media/data-binding-with-poco.png\" alt=\"Data-binding with poco\"/\u003e\u003c/p\u003e\u003cp\u003eDon\u0026#x27;t panic! Hope is not lost. Instead of relying on Blazor\u0026#x27;s data-binding let\u0026#x27;s try responding to the \u003ccode\u003eonchange\u003c/code\u003e event manually.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* UpdatePerson.cshtml *@\n...\n    \u0026lt;input type=\u0026quot;text\u0026quot; value=\u0026quot;@person.Name\u0026quot; onchange=\u0026quot;@OnChange\u0026quot; /\u0026gt;\n...\n@functions {\n    ...\n    private void OnChange(UIChangeEventArgs e)\n    {\n        person.Name = (string)e.Value;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you refresh the browser, you will see that we still have the same functionality. Well, we didn\u0026#x27;t break anything. We still have component-scoped data-binding. Why use an event listener instead of bind? Using an event listener allows us to have side effects, such as calling \u003ccode\u003eStateHasChanged\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* UpdatePerson.cshtml *@\nprivate void OnChange(UIChangeEventArgs e)\n{\n    person.Name = (string)e.Value;\n    StateHasChanged();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eStateHasChanged\u003c/code\u003e, if you haven\u0026#x27;t guessed, is a Blazor function that tells the system that the state has changed which, in turn, triggers a rerender. Blazor renders UI similar to many popular JS frameworks. It maintains a virtual dom. When a rerender occurs, Blazor generates a new virtual dom, diffs it with the previous virtual dom and then minimally updates the real dom.\u003c/p\u003e\u003cp\u003eMaybe, just maybe, manually calling \u003ccode\u003eStateHasChanged\u003c/code\u003e causes Blazor to rerender and diff the entire virtual dom and not just the local component dom. And...\u003c/p\u003e\u003cp\u003e\u003cimg src=\"/media/data-binding-with-satehaschanged.png\" alt=\"Data-binding with statehaschanged\"/\u003e\u003c/p\u003e\u003cp\u003eTurns out, \u003ccode\u003eStateHasChanged\u003c/code\u003e is scoped to the current component and child components. No different from bind.\u003c/p\u003e\u003cp\u003eWhat gives? DisplayPerson and UpdatePerson receive the same Person object. It is an object! It has to be passed by reference, right? This is true. DisplayPerson and UpdatePerson receive a reference to the same object. The problem lies in how rerendering works in Blazor.\u003c/p\u003e\u003cp\u003eLet\u0026#x27;s prove that the shortcoming lies within the rendering mechanism. Add the following code to DisplayPerson\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e...\n@functions {\n...\n    protected async override Task OnInitAsync()\n        {\n            await base.OnInitAsync();\n            System.Timers.Timer timer = new System.Timers.Timer(10000);\n            await Task.Delay(6000);\n            StateHasChanged();\n        }\n...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAfter 6 seconds, DisplayPerson calls \u003ccode\u003eStatehasChanged\u003c/code\u003e, triggering a rerender. This should give us enough time to load the page, update the state within the UpdatePerson component and wait and see if DisplayPerson will display the updated name after StateHasChanged has been called. Go quick. You have 6 seconds. If all goes well, DisplayPerson, after 6 seconds, should display the updated name since it is referencing the same object.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"/media/data-binding-with-a-delay.gif\" alt=\"Data-binding with a delay\"/\u003e\u003c/p\u003e\u003cp\u003eNotice that the name is updating to match user input\u003c/p\u003e\u003chr/\u003e\u003ch2\u003eConclusion\u003c/h2\u003e\u003cp\u003eIn summary, Blazor supports component-based data-binding, a process for keeping the ViewModel and view in sync. Data-binding is component based and will not work across components. In future articles, I will examine methods for sharing data across components and ensuring components use and reflect the most up-to-date data.\u003c/p\u003e","scope":{}},"frontMatter":{"template":"post","title":"Blazor State Management Part I - Data-Binding","slug":"blazor-state-management-1-data-binding","published":true,"date":"2019-03-08","description":"Data-Binding. It's the magical glue that binds an application's UI to its business model. Or, more formally, It's a process for updating UI when application state changes and vice versa, keeping the state in sync with changes occurring in the UI. Blazor supports data-binding, but to what extent?","category":"Blazor","tags":["Blazor"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"blazor-state-management-1-data-binding"},"buildId":"it86kmHuw1morl_kI-W8Y","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-ca7eb3eb57fbc5dfe87d.js"></script><script src="/_next/static/chunks/main-15cc7adb6c68e37a6c83.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.386717e5d53cbb6c2786.js" async=""></script><script src="/_next/static/chunks/pages/_app-bc7fdccc4b180668915c.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-4a2fe920f2221d4f2899.js" async=""></script><script src="/_next/static/it86kmHuw1morl_kI-W8Y/_buildManifest.js" async=""></script><script src="/_next/static/it86kmHuw1morl_kI-W8Y/_ssgManifest.js" async=""></script></body></html>