<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/4c0306d5b03180f9727b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4c0306d5b03180f9727b.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-15cc7adb6c68e37a6c83.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.386717e5d53cbb6c2786.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-bc7fdccc4b180668915c.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bslug%5D-4a2fe920f2221d4f2899.js" as="script"/></head><body><div id="__next"><div class="Layout__StyledMain-sc-1ho0hv8-0 fsweVq"><header class="Header__StyledHeader-wxqfda-0 bIiJxr"><div><h2><a href="/">Couch Dev</a> <small>Prerecorded from my couch, it&#x27;s a dev making sense of dev things!</small></h2></div></header><div><main><div><blockquote><p><strong>This article explores cascading values in Blazor 0.7.0</strong></p><p><strong>The source code for this article can be found <a href="https://github.com/dworthen/BlazorStateManagement/tree/part-03-cascading-parameters">here</a></strong></p></blockquote><p><strong>This article is part of a Blazor state management exploration series.</strong></p><ol><li><a href="/posts/blazor-state-management-1-data-binding">Blazor State Management Part I - Data-Binding</a></li><li><a href="/posts/blazor-state-management-2-event-delegation">Blazor State Management Part II - Event Delegation</a></li><li>Blazor State Management Part III - Cascading Parameters</li></ol><hr/><p><a href="/posts/blazor-state-management-2-event-delegation">The last article</a> ended with a question. How do we share data within the following component structure?</p><p><img src="/media/event-delegation-complicated.png" alt="Cascading parameters."/></p><p>With event delegation, we could update middle components to accept a <code>person</code> parameter and pass it through to child components that need it. We would also need to pass event handlers through the middle components. A doable, but a messy and cumbersome process.</p><p>Ideally, we would pass parameters from the parent component directly to child components that need them, no matter how nested the child components are. Well, it turns out, we can. <a href="https://docs.microsoft.com/en-us/aspnet/core/razor-components/components?view=aspnetcore-3.0#cascading-values-and-parameters">CascadingValue</a> is a unique tag that allows us to hoist parameters for child components, even nested ones, to acccess. This should feel familiar to anyone who has used <a href="https://reactjs.org/docs/context.html">React context</a>.</p><p>Let&#x27;s create a <code>MiddleComponent</code> to contain the <code>DisplayPerson</code> and <code>UpdatePerson</code> components.</p><pre><code class="language-aspnet">@* MiddleComponent.cshtml *@
&lt;div class=&quot;boxed&quot;&gt;
    &lt;h4&gt;DisplayPerson Component&lt;/h4&gt;
    &lt;DisplayPerson&gt;&lt;/DisplayPerson3&gt;
&lt;/div&gt;
&lt;div class=&quot;boxed&quot;&gt;
    &lt;h4&gt;UpdatePerson Componet&lt;/h4&gt;
    &lt;UpdatePerson&gt;&lt;/UpdatePerson3&gt;
&lt;/div&gt;
</code></pre><p>Notice that we are no longer passing parameters to <code>DisplayPerson</code> or <code>UpdatePerson</code>. This is because the components will check the hoisted space for the values instead of receiving them directly as parameters. Update <code>index.cshtml</code> to use the newly created <code>MiddleComponent</code>.</p><pre><code class="language-aspnet">@* index.cshtml *@
...
&lt;MiddleComponent&gt;&lt;/MiddleComponent&gt;

@functions {
    protected Person person { get; set; } = new Person { Name = &quot;Derek&quot; };
    ...
}
</code></pre><p>This will not work. Remember, <code>DisplayPerson</code> and <code>UpdatePerson</code> need a <code>Person</code> object to work with. So let&#x27;s wrap <code>MiddleComponent</code> in a <code>CascadingValue</code> component to hoist our <code>person</code> object.</p><pre><code class="language-aspnet">@* index.cshtml *@
...
&lt;CascadingValue Value=&quot;@person&quot;&gt;
    &lt;MiddleComponent&gt;&lt;/MiddleComponent&gt;
&lt;/CascadingValue&gt;
...
</code></pre><p>This is still not enough. <code>UpdatePerson</code> also expects a function parameter. A function that will handle updating the state when necessary. Each <code>CascadingValue</code> can only hoist one value so we will need to nest tags. </p><pre><code class="language-aspnet">@* index.cshtml *@
&lt;CascadingValue Value=&quot;@person&quot;&gt;
    &lt;CascadingValue 
        Value=&quot;@HandleChange&quot; 
        Name=&quot;HandleChange&quot; 
        T=&quot;Action&lt;UIChangeEventArgs&gt;&quot;&gt;
        &lt;MiddleComponent&gt;&lt;/MiddleComponent&gt;
    &lt;/CascadingValue&gt;
&lt;/CascadingValue&gt;

@functions {
    protected Person person { get; set; } = new Person { Name = &quot;Derek&quot; };
    protected void HandleChange (UIChangeEventArgs e)
    {
        person.Name = e.Value.ToString();
        StateHasChanged();
    }
}
</code></pre><p>The second <code>CascadingValue</code> component is hoisting a named parameter. Since the parameter is a method, we need to help Blazor identify the parameter type by specifying the type with the <code>T</code> parameter.</p><p>Next, we need to update <code>UpdatePerson</code> and <code>DisplayPerson</code> to use <code>CascadingParameters</code> instead of normal parameters. We only need to update the decorators to specify <code>CascadingParameters</code>. Nothing else needs to change.</p><pre><code class="language-apsnet">@* UpdatePerson.cshtml *@
...
@functions {
    [CascadingParameter] 
    protected Person person { get; set; }
    [CascadingParameter(Name = &quot;HandleChange&quot;)] 
    protected Action&lt;UIChangeEventArgs&gt; CustomOnChange { get; set; }
    ...
}
</code></pre><pre><code class="language-aspnet">@* DisplayPerson.cshtml *@
...
@functions {
    [CascadingParameter] protected Person person { get; set; }
}
</code></pre><p>Our application should work as it did at the end of the event delegation article. Updating the person&#x27;s name using the input field should update the name displayed in all components. </p><hr/><h2>Conclusion</h2><p>Yes, it is possible to use cascading parameters to share state throughout an application, but it is messy. The Blazor docs use CSS style rules or theme information as an example for using cascading parameters. read-only UI state or theme information are good candidates for cascading parameters. Otherwise, not only do the values need to be cascaded but so do the methods that will be responsible for updating the hoisted values. Not to mention, <code>CascadingValue</code> can only hoist one value at a time, requiring nested tags for each cascading value.</p></div></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i \u003c arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i \u003c sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i \u003c sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"This article explores cascading values in Blazor 0.7.0\")), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"The source code for this article can be found \", mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://github.com/dworthen/BlazorStateManagement/tree/part-03-cascading-parameters\"\n  }, \"here\")))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"This article is part of a Blazor state management exploration series.\")), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/posts/blazor-state-management-1-data-binding\"\n  }, \"Blazor State Management Part I - Data-Binding\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/posts/blazor-state-management-2-event-delegation\"\n  }, \"Blazor State Management Part II - Event Delegation\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Blazor State Management Part III - Cascading Parameters\")), mdx(\"hr\", null), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/posts/blazor-state-management-2-event-delegation\"\n  }, \"The last article\"), \" ended with a question. How do we share data within the following component structure?\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/media/event-delegation-complicated.png\",\n    \"alt\": \"Cascading parameters.\"\n  })), mdx(\"p\", null, \"With event delegation, we could update middle components to accept a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"person\"), \" parameter and pass it through to child components that need it. We would also need to pass event handlers through the middle components. A doable, but a messy and cumbersome process.\"), mdx(\"p\", null, \"Ideally, we would pass parameters from the parent component directly to child components that need them, no matter how nested the child components are. Well, it turns out, we can. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/aspnet/core/razor-components/components?view=aspnetcore-3.0#cascading-values-and-parameters\"\n  }, \"CascadingValue\"), \" is a unique tag that allows us to hoist parameters for child components, even nested ones, to acccess. This should feel familiar to anyone who has used \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/docs/context.html\"\n  }, \"React context\"), \".\"), mdx(\"p\", null, \"Let's create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MiddleComponent\"), \" to contain the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DisplayPerson\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \" components.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* MiddleComponent.cshtml *@\\n\u003cdiv class=\\\"boxed\\\"\u003e\\n    \u003ch4\u003eDisplayPerson Component\u003c/h4\u003e\\n    \u003cDisplayPerson\u003e\u003c/DisplayPerson3\u003e\\n\u003c/div\u003e\\n\u003cdiv class=\\\"boxed\\\"\u003e\\n    \u003ch4\u003eUpdatePerson Componet\u003c/h4\u003e\\n    \u003cUpdatePerson\u003e\u003c/UpdatePerson3\u003e\\n\u003c/div\u003e\\n\")), mdx(\"p\", null, \"Notice that we are no longer passing parameters to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DisplayPerson\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \". This is because the components will check the hoisted space for the values instead of receiving them directly as parameters. Update \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.cshtml\"), \" to use the newly created \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MiddleComponent\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* index.cshtml *@\\n...\\n\u003cMiddleComponent\u003e\u003c/MiddleComponent\u003e\\n\\n@functions {\\n    protected Person person { get; set; } = new Person { Name = \\\"Derek\\\" };\\n    ...\\n}\\n\")), mdx(\"p\", null, \"This will not work. Remember, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DisplayPerson\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \" need a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" object to work with. So let's wrap \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MiddleComponent\"), \" in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CascadingValue\"), \" component to hoist our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"person\"), \" object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* index.cshtml *@\\n...\\n\u003cCascadingValue Value=\\\"@person\\\"\u003e\\n    \u003cMiddleComponent\u003e\u003c/MiddleComponent\u003e\\n\u003c/CascadingValue\u003e\\n...\\n\")), mdx(\"p\", null, \"This is still not enough. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \" also expects a function parameter. A function that will handle updating the state when necessary. Each \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CascadingValue\"), \" can only hoist one value so we will need to nest tags. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* index.cshtml *@\\n\u003cCascadingValue Value=\\\"@person\\\"\u003e\\n    \u003cCascadingValue \\n        Value=\\\"@HandleChange\\\" \\n        Name=\\\"HandleChange\\\" \\n        T=\\\"Action\u003cUIChangeEventArgs\u003e\\\"\u003e\\n        \u003cMiddleComponent\u003e\u003c/MiddleComponent\u003e\\n    \u003c/CascadingValue\u003e\\n\u003c/CascadingValue\u003e\\n\\n@functions {\\n    protected Person person { get; set; } = new Person { Name = \\\"Derek\\\" };\\n    protected void HandleChange (UIChangeEventArgs e)\\n    {\\n        person.Name = e.Value.ToString();\\n        StateHasChanged();\\n    }\\n}\\n\")), mdx(\"p\", null, \"The second \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CascadingValue\"), \" component is hoisting a named parameter. Since the parameter is a method, we need to help Blazor identify the parameter type by specifying the type with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T\"), \" parameter.\"), mdx(\"p\", null, \"Next, we need to update \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpdatePerson\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DisplayPerson\"), \" to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CascadingParameters\"), \" instead of normal parameters. We only need to update the decorators to specify \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CascadingParameters\"), \". Nothing else needs to change.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-apsnet\"\n  }, \"@* UpdatePerson.cshtml *@\\n...\\n@functions {\\n    [CascadingParameter] \\n    protected Person person { get; set; }\\n    [CascadingParameter(Name = \\\"HandleChange\\\")] \\n    protected Action\u003cUIChangeEventArgs\u003e CustomOnChange { get; set; }\\n    ...\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-aspnet\"\n  }, \"@* DisplayPerson.cshtml *@\\n...\\n@functions {\\n    [CascadingParameter] protected Person person { get; set; }\\n}\\n\")), mdx(\"p\", null, \"Our application should work as it did at the end of the event delegation article. Updating the person's name using the input field should update the name displayed in all components. \"), mdx(\"hr\", null), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"Yes, it is possible to use cascading parameters to share state throughout an application, but it is messy. The Blazor docs use CSS style rules or theme information as an example for using cascading parameters. read-only UI state or theme information are good candidates for cascading parameters. Otherwise, not only do the values need to be cascaded but so do the methods that will be responsible for updating the hoisted values. Not to mention, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CascadingValue\"), \" can only hoist one value at a time, requiring nested tags for each cascading value.\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003eThis article explores cascading values in Blazor 0.7.0\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eThe source code for this article can be found \u003ca href=\"https://github.com/dworthen/BlazorStateManagement/tree/part-03-cascading-parameters\"\u003ehere\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e\u003cstrong\u003eThis article is part of a Blazor state management exploration series.\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003ca href=\"/posts/blazor-state-management-1-data-binding\"\u003eBlazor State Management Part I - Data-Binding\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"/posts/blazor-state-management-2-event-delegation\"\u003eBlazor State Management Part II - Event Delegation\u003c/a\u003e\u003c/li\u003e\u003cli\u003eBlazor State Management Part III - Cascading Parameters\u003c/li\u003e\u003c/ol\u003e\u003chr/\u003e\u003cp\u003e\u003ca href=\"/posts/blazor-state-management-2-event-delegation\"\u003eThe last article\u003c/a\u003e ended with a question. How do we share data within the following component structure?\u003c/p\u003e\u003cp\u003e\u003cimg src=\"/media/event-delegation-complicated.png\" alt=\"Cascading parameters.\"/\u003e\u003c/p\u003e\u003cp\u003eWith event delegation, we could update middle components to accept a \u003ccode\u003eperson\u003c/code\u003e parameter and pass it through to child components that need it. We would also need to pass event handlers through the middle components. A doable, but a messy and cumbersome process.\u003c/p\u003e\u003cp\u003eIdeally, we would pass parameters from the parent component directly to child components that need them, no matter how nested the child components are. Well, it turns out, we can. \u003ca href=\"https://docs.microsoft.com/en-us/aspnet/core/razor-components/components?view=aspnetcore-3.0#cascading-values-and-parameters\"\u003eCascadingValue\u003c/a\u003e is a unique tag that allows us to hoist parameters for child components, even nested ones, to acccess. This should feel familiar to anyone who has used \u003ca href=\"https://reactjs.org/docs/context.html\"\u003eReact context\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eLet\u0026#x27;s create a \u003ccode\u003eMiddleComponent\u003c/code\u003e to contain the \u003ccode\u003eDisplayPerson\u003c/code\u003e and \u003ccode\u003eUpdatePerson\u003c/code\u003e components.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* MiddleComponent.cshtml *@\n\u0026lt;div class=\u0026quot;boxed\u0026quot;\u0026gt;\n    \u0026lt;h4\u0026gt;DisplayPerson Component\u0026lt;/h4\u0026gt;\n    \u0026lt;DisplayPerson\u0026gt;\u0026lt;/DisplayPerson3\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;div class=\u0026quot;boxed\u0026quot;\u0026gt;\n    \u0026lt;h4\u0026gt;UpdatePerson Componet\u0026lt;/h4\u0026gt;\n    \u0026lt;UpdatePerson\u0026gt;\u0026lt;/UpdatePerson3\u0026gt;\n\u0026lt;/div\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNotice that we are no longer passing parameters to \u003ccode\u003eDisplayPerson\u003c/code\u003e or \u003ccode\u003eUpdatePerson\u003c/code\u003e. This is because the components will check the hoisted space for the values instead of receiving them directly as parameters. Update \u003ccode\u003eindex.cshtml\u003c/code\u003e to use the newly created \u003ccode\u003eMiddleComponent\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* index.cshtml *@\n...\n\u0026lt;MiddleComponent\u0026gt;\u0026lt;/MiddleComponent\u0026gt;\n\n@functions {\n    protected Person person { get; set; } = new Person { Name = \u0026quot;Derek\u0026quot; };\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis will not work. Remember, \u003ccode\u003eDisplayPerson\u003c/code\u003e and \u003ccode\u003eUpdatePerson\u003c/code\u003e need a \u003ccode\u003ePerson\u003c/code\u003e object to work with. So let\u0026#x27;s wrap \u003ccode\u003eMiddleComponent\u003c/code\u003e in a \u003ccode\u003eCascadingValue\u003c/code\u003e component to hoist our \u003ccode\u003eperson\u003c/code\u003e object.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* index.cshtml *@\n...\n\u0026lt;CascadingValue Value=\u0026quot;@person\u0026quot;\u0026gt;\n    \u0026lt;MiddleComponent\u0026gt;\u0026lt;/MiddleComponent\u0026gt;\n\u0026lt;/CascadingValue\u0026gt;\n...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is still not enough. \u003ccode\u003eUpdatePerson\u003c/code\u003e also expects a function parameter. A function that will handle updating the state when necessary. Each \u003ccode\u003eCascadingValue\u003c/code\u003e can only hoist one value so we will need to nest tags. \u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* index.cshtml *@\n\u0026lt;CascadingValue Value=\u0026quot;@person\u0026quot;\u0026gt;\n    \u0026lt;CascadingValue \n        Value=\u0026quot;@HandleChange\u0026quot; \n        Name=\u0026quot;HandleChange\u0026quot; \n        T=\u0026quot;Action\u0026lt;UIChangeEventArgs\u0026gt;\u0026quot;\u0026gt;\n        \u0026lt;MiddleComponent\u0026gt;\u0026lt;/MiddleComponent\u0026gt;\n    \u0026lt;/CascadingValue\u0026gt;\n\u0026lt;/CascadingValue\u0026gt;\n\n@functions {\n    protected Person person { get; set; } = new Person { Name = \u0026quot;Derek\u0026quot; };\n    protected void HandleChange (UIChangeEventArgs e)\n    {\n        person.Name = e.Value.ToString();\n        StateHasChanged();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe second \u003ccode\u003eCascadingValue\u003c/code\u003e component is hoisting a named parameter. Since the parameter is a method, we need to help Blazor identify the parameter type by specifying the type with the \u003ccode\u003eT\u003c/code\u003e parameter.\u003c/p\u003e\u003cp\u003eNext, we need to update \u003ccode\u003eUpdatePerson\u003c/code\u003e and \u003ccode\u003eDisplayPerson\u003c/code\u003e to use \u003ccode\u003eCascadingParameters\u003c/code\u003e instead of normal parameters. We only need to update the decorators to specify \u003ccode\u003eCascadingParameters\u003c/code\u003e. Nothing else needs to change.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-apsnet\"\u003e@* UpdatePerson.cshtml *@\n...\n@functions {\n    [CascadingParameter] \n    protected Person person { get; set; }\n    [CascadingParameter(Name = \u0026quot;HandleChange\u0026quot;)] \n    protected Action\u0026lt;UIChangeEventArgs\u0026gt; CustomOnChange { get; set; }\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode class=\"language-aspnet\"\u003e@* DisplayPerson.cshtml *@\n...\n@functions {\n    [CascadingParameter] protected Person person { get; set; }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOur application should work as it did at the end of the event delegation article. Updating the person\u0026#x27;s name using the input field should update the name displayed in all components. \u003c/p\u003e\u003chr/\u003e\u003ch2\u003eConclusion\u003c/h2\u003e\u003cp\u003eYes, it is possible to use cascading parameters to share state throughout an application, but it is messy. The Blazor docs use CSS style rules or theme information as an example for using cascading parameters. read-only UI state or theme information are good candidates for cascading parameters. Otherwise, not only do the values need to be cascaded but so do the methods that will be responsible for updating the hoisted values. Not to mention, \u003ccode\u003eCascadingValue\u003c/code\u003e can only hoist one value at a time, requiring nested tags for each cascading value.\u003c/p\u003e","scope":{}},"frontMatter":{"template":"post","title":"Blazor State Management Part III - Cascading Parameters","slug":"blazor-state-management-3-cascading-parameters","published":true,"date":"2019-03-16","description":"Cascading parameters provides a way to share data and behavior from ancestor components to child components without having to manually pass parameters down in intermediate components. Components can access the data it needs without requiring parent components to manage data dependencies. In this article, we will explore using cascading parameters, along with event delegation, in order to share data throughout a component tree.","category":"Blazor","tags":["Blazor"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"blazor-state-management-3-cascading-parameters"},"buildId":"it86kmHuw1morl_kI-W8Y","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-ca7eb3eb57fbc5dfe87d.js"></script><script src="/_next/static/chunks/main-15cc7adb6c68e37a6c83.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.386717e5d53cbb6c2786.js" async=""></script><script src="/_next/static/chunks/pages/_app-bc7fdccc4b180668915c.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-4a2fe920f2221d4f2899.js" async=""></script><script src="/_next/static/it86kmHuw1morl_kI-W8Y/_buildManifest.js" async=""></script><script src="/_next/static/it86kmHuw1morl_kI-W8Y/_ssgManifest.js" async=""></script></body></html>